// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
static DATAMODEL_STR : & 'static str = "generator jsclient {\r\n provider = \"prisma-client-js\"\r\n}\r\n\r\ngenerator rsclient {\r\n  provider = \"cargo prisma\"\r\n  output   = \"../project-setup-rs/src/db.rs\"\r\n}\r\n\r\ndatasource db {\r\n  provider = \"postgresql\"\r\n  url      = env(\"DATABASE_URL\")\r\n}\r\n\r\nmodel User {\r\n  id            String   @id @default(cuid())\r\n  name          String\r\n  email         String   @unique\r\n  password_hash String\r\n  created_at    DateTime @default(now())\r\n  progress      Progress @relation(fields: [progress_id], references: [id])\r\n  progress_id   String\r\n}\r\n\r\nmodel LoginToken {\r\n  id      String   @id @default(cuid())\r\n  user_id String   @unique\r\n  time    DateTime @default(now())\r\n  value   String   @unique\r\n}\r\n\r\nmodel SubjectProgress {\r\n  subject     SubjectIndex @relation(fields: [subject_id], references: [subjectId])\r\n  subject_id  Int\r\n  level       Int\r\n  skill_level Int          @default(0)\r\n  next_review DateTime\r\n  progress_id String\r\n  progress    Progress     @relation(fields: [progress_id], references: [id])\r\n\r\n  @@unique([subject_id, progress_id])\r\n}\r\n\r\nmodel Progress {\r\n  id               String            @id @default(cuid())\r\n  subject_progress SubjectProgress[]\r\n  User             User[]\r\n  current_level    Int               @default(1)\r\n}\r\n\r\nmodel SubjectMeaning {\r\n  id                  String             @id @default(cuid())\r\n  accepted_answer     Boolean\r\n  meaning             String\r\n  primary             Boolean\r\n  RadicalSubject      RadicalSubject?    @relation(fields: [radicalSubjectId], references: [id])\r\n  radicalSubjectId    Int?\r\n  KanjiSubject        KanjiSubject?      @relation(fields: [kanjiSubjectId], references: [id])\r\n  kanjiSubjectId      Int?\r\n  VocabularySubject   VocabularySubject? @relation(fields: [vocabularySubjectId], references: [id])\r\n  vocabularySubjectId Int?\r\n}\r\n\r\nmodel AuxiliaryMeaning {\r\n  id                  String             @id @default(cuid())\r\n  meaning             String\r\n  auxiliary_type      String\r\n  RadicalSubject      RadicalSubject?    @relation(fields: [radicalSubjectId], references: [id])\r\n  radicalSubjectId    Int?\r\n  KanjiSubject        KanjiSubject?      @relation(fields: [kanjiSubjectId], references: [id])\r\n  kanjiSubjectId      Int?\r\n  VocabularySubject   VocabularySubject? @relation(fields: [vocabularySubjectId], references: [id])\r\n  vocabularySubjectId Int?\r\n}\r\n\r\nenum ReadingType {\r\n  ONYOMI\r\n  KUNYOMI\r\n  NANORI\r\n}\r\n\r\nmodel KanjiReading {\r\n  id             String       @id @default(cuid())\r\n  reading        String\r\n  reading_type   ReadingType\r\n  primary        Boolean\r\n  KanjiSubject   KanjiSubject @relation(fields: [kanjiSubjectId], references: [id])\r\n  kanjiSubjectId Int\r\n}\r\n\r\nmodel VocabularyReading {\r\n  id                  String            @id @default(cuid())\r\n  reading             String\r\n  primary             Boolean\r\n  accepted_answer     Boolean\r\n  VocabularySubject   VocabularySubject @relation(fields: [vocabularySubjectId], references: [id])\r\n  vocabularySubjectId Int\r\n}\r\n\r\nenum SubjectType {\r\n  KANJI\r\n  VOCABULARY\r\n  RADICAL\r\n}\r\n\r\nmodel SubjectIndex {\r\n  subject_type    SubjectType\r\n  subjectId       Int                 @id\r\n  radical_ref     RadicalSubject[]\r\n  kanji_ref_amal  KanjiSubject[]      @relation(name: \"amalgamation_subjects\")\r\n  kanji_ref_sim   KanjiSubject[]      @relation(name: \"visually_similar_subjects\")\r\n  kanji_ref_comp  KanjiSubject[]      @relation(name: \"component_subjects\")\r\n  vocab_ref       VocabularySubject[]\r\n  SubjectProgress SubjectProgress[]\r\n}\r\n\r\nmodel RadicalSubject {\r\n  id                    Int                @id\r\n  amalgamation_subjects SubjectIndex[]\r\n  auxiliary_meanings    AuxiliaryMeaning[]\r\n  characters            String?\r\n  lesson_position       Int\r\n  level                 Int\r\n  meaning_mnemonic      String\r\n  meanings              SubjectMeaning[]\r\n}\r\n\r\nmodel KanjiSubject {\r\n  id                        Int                @id\r\n  amalgamation_subjects     SubjectIndex[]     @relation(name: \"amalgamation_subjects\")\r\n  auxiliary_meanings        AuxiliaryMeaning[]\r\n  characters                String\r\n  component_subjects        SubjectIndex[]     @relation(name: \"component_subjects\")\r\n  lesson_position           Int\r\n  level                     Int\r\n  meaning_hint              String\r\n  meaning_mnemonic          String\r\n  meanings                  SubjectMeaning[]\r\n  reading_hint              String\r\n  reading_mnemonic          String\r\n  readings                  KanjiReading[]\r\n  visually_similar_subjects SubjectIndex[]     @relation(name: \"visually_similar_subjects\")\r\n}\r\n\r\nmodel ContextSentence {\r\n  id                  String             @id @default(cuid())\r\n  en                  String\r\n  ja                  String\r\n  VocabularySubject   VocabularySubject? @relation(fields: [vocabularySubjectId], references: [id])\r\n  vocabularySubjectId Int?\r\n}\r\n\r\nmodel VocabularySubject {\r\n  id                 Int                 @id\r\n  auxiliary_meanings AuxiliaryMeaning[]\r\n  characters         String\r\n  component_subjects SubjectIndex[]\r\n  context_sentences  ContextSentence[]\r\n  lesson_position    Int\r\n  level              Int\r\n  meaning_mnemonic   String\r\n  meanings           SubjectMeaning[]\r\n  reading_mnemonic   String\r\n  readings           VocabularyReading[]\r\n}\r\n" ;
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if std::path::Path::new("./schema.prisma").exists() {
            url
        } else if std::path::Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let (db_name, executor) =
        ::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
    let internal_model =
        ::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(DATAMODEL_STR)
            .build(db_name);
    let query_schema = std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
        internal_model,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient::_new(executor, query_schema))
}
pub mod user {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::EmailEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EmailLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EmailLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EmailGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EmailGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EmailContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EmailStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EmailEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::EmailMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EmailNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmail(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("email").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("email").build()
            }
        }
    }
    pub mod password_hash {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PasswordHashEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PasswordHash(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PasswordHashInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PasswordHashNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::PasswordHashLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::PasswordHashLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::PasswordHashGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::PasswordHashGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::PasswordHashContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::PasswordHashStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::PasswordHashEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::PasswordHashMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::PasswordHashNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPasswordHash(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PasswordHash(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("password_hash").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PasswordHash(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("password_hash").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub mod progress {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<progress::WhereParam>) -> WhereParam {
            WhereParam::ProgressIs(value)
        }
        pub fn is_not(value: Vec<progress::WhereParam>) -> WhereParam {
            WhereParam::ProgressIsNot(value)
        }
        pub struct Fetch(pub progress::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<progress::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Progress(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(progress::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: progress::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(progress::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectProgress(value.0)
            }
        }
        pub enum Include {
            Select(Vec<progress::SelectParam>),
            Include(Vec<progress::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Progress(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("progress");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = progress::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(progress::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<progress::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<progress::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<progress::SelectParam>),
            Include(Vec<progress::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Progress(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("progress");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(progress::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<progress::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<progress::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod progress_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ProgressIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ProgressId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ProgressIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ProgressIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ProgressIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ProgressIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ProgressIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ProgressIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ProgressIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ProgressIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ProgressIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ProgressIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ProgressIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetProgressId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ProgressId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("progress_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ProgressId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("progress_id").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "id",
            "name",
            "email",
            "password_hash",
            "created_at",
            "progress_id",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        name: String,
        email: String,
        password_hash: String,
        progress: super::progress::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        super::progress::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (name, email, password_hash, progress, _params)
    }
    #[macro_export]
    macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , email , password_hash , created_at , progress , progress_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (email) , stringify ! (password_hash) , stringify ! (created_at) , stringify ! (progress_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "email" , "password_hash" , "created_at" , "progress" , "progress_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; email) => { String } ; (@ field_type ; password_hash) => { String } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { progress :: Data } ; (@ field_type ; progress) => { crate :: prisma :: progress :: Data } ; (@ field_type ; progress_id) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "User" , available fields are "id, name, email, password_hash, created_at, progress, progress_id")) } ; (@ field_module ; progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: progress :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: name :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: email :: Select) } ; (@ selection_field_to_selection_param ; password_hash) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: password_hash :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: created_at :: Select) } ; (@ selection_field_to_selection_param ; progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: progress :: Select :: $ selection_mode ($ crate :: prisma :: progress :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: progress :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; progress_id) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: progress_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; password_hash) => { "password_hash" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; progress) => { "progress" } ; (@ field_serde_name ; progress_id) => { "progress_id" } ; }
    pub use _select_user as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Email(email::Select),
        PasswordHash(password_hash::Select),
        CreatedAt(created_at::Select),
        Progress(progress::Select),
        ProgressId(progress_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::PasswordHash(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Progress(data) => data.to_selection(),
                Self::ProgressId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { progress } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : String , pub name : String , pub email : String , pub password_hash : String , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub progress_id : String , $ (pub $ field : $ crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (email) , stringify ! (password_hash) , stringify ! (created_at) , stringify ! (progress_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , email , password_hash , created_at , progress_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; email) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; password_hash) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; progress_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; email) => Ok (Field :: email) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; password_hash) => Ok (Field :: password_hash) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; progress_id) => Ok (Field :: progress_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut email = None ; let mut password_hash = None ; let mut created_at = None ; let mut progress_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email))) ; } email = Some (map . next_value () ?) ; } Field :: password_hash => { if password_hash . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; password_hash))) ; } password_hash = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } Field :: progress_id => { if progress_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; progress_id))) ; } progress_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; name))) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email))) ? ; let password_hash = password_hash . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; password_hash))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at))) ? ; let progress_id = progress_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; progress_id))) ? ; Ok (Data { id , name , email , password_hash , created_at , progress_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "email" , "password_hash" , "created_at" , "progress" , "progress_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { progress :: Data } ; (@ field_type ; progress) => { crate :: prisma :: progress :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "progress")) } ; (@ field_module ; progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: progress :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: progress :: Include :: $ selection_mode ($ crate :: prisma :: progress :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: progress :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; password_hash) => { "password_hash" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; progress) => { "progress" } ; (@ field_serde_name ; progress_id) => { "progress_id" } ; }
    pub use _include_user as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Email(email::Include),
        PasswordHash(password_hash::Include),
        CreatedAt(created_at::Include),
        Progress(progress::Include),
        ProgressId(progress_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::PasswordHash(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Progress(data) => data.to_selection(),
                Self::ProgressId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "password_hash")]
        pub password_hash: String,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "progress")]
        pub progress: Option<Box<super::progress::Data>>,
        #[serde(rename = "progress_id")]
        pub progress_id: String,
    }
    impl Data {
        pub fn progress(
            &self,
        ) -> Result<&super::progress::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.progress
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(progress),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Progress(super::progress::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Progress(args) => {
                    let mut selections = super::progress::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("progress");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetEmail(String),
        SetPasswordHash(String),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ConnectProgress(super::progress::UniqueWhereParam),
        SetProgressId(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEmail(value) => (
                    "email".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPasswordHash(value) => (
                    "password_hash".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::ConnectProgress(where_param) => (
                    "progress".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::progress::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetProgressId(value) => (
                    "progress_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        PasswordHash(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        ProgressId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    "email".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PasswordHash(direction) => (
                    "password_hash".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ProgressId(direction) => (
                    "progress_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameMode(QueryMode),
        NameNot(String),
        EmailEquals(String),
        EmailInVec(Vec<String>),
        EmailNotInVec(Vec<String>),
        EmailLt(String),
        EmailLte(String),
        EmailGt(String),
        EmailGte(String),
        EmailContains(String),
        EmailStartsWith(String),
        EmailEndsWith(String),
        EmailMode(QueryMode),
        EmailNot(String),
        PasswordHashEquals(String),
        PasswordHashInVec(Vec<String>),
        PasswordHashNotInVec(Vec<String>),
        PasswordHashLt(String),
        PasswordHashLte(String),
        PasswordHashGt(String),
        PasswordHashGte(String),
        PasswordHashContains(String),
        PasswordHashStartsWith(String),
        PasswordHashEndsWith(String),
        PasswordHashMode(QueryMode),
        PasswordHashNot(String),
        CreatedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAtInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        CreatedAtNotInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        CreatedAtLt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAtLte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAtGt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAtGte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAtNot(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ProgressIs(Vec<super::progress::WhereParam>),
        ProgressIsNot(Vec<super::progress::WhereParam>),
        ProgressIdEquals(String),
        ProgressIdInVec(Vec<String>),
        ProgressIdNotInVec(Vec<String>),
        ProgressIdLt(String),
        ProgressIdLte(String),
        ProgressIdGt(String),
        ProgressIdGte(String),
        ProgressIdContains(String),
        ProgressIdStartsWith(String),
        ProgressIdEndsWith(String),
        ProgressIdMode(QueryMode),
        ProgressIdNot(String),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NameMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NameNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::EmailNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::EmailLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::EmailNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::PasswordHashNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::PasswordHashLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PasswordHashMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::PasswordHashNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "password_hash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ProgressIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "progress",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ProgressIsNot(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "progress",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ProgressIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ProgressIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ProgressIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ProgressIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        EmailEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmailEquals(value) => Self::EmailEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            name: String,
            email: String,
            password_hash: String,
            progress: super::progress::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(name::set(name));
            _params.push(email::set(email));
            _params.push(password_hash::set(password_hash));
            _params.push(progress::connect(progress));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                super::progress::UniqueWhereParam,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, email, password_hash, progress, mut _params)| {
                    _params.push(name::set(name));
                    _params.push(email::set(email));
                    _params.push(password_hash::set(password_hash));
                    _params.push(progress::connect(progress));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, email, password_hash, progress, mut _params): (
                String,
                String,
                String,
                super::progress::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(name::set(name));
            _params.push(email::set(email));
            _params.push(password_hash::set(password_hash));
            _params.push(progress::connect(progress));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                vec![],
            )
        }
    }
}
pub mod login_token {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod time {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::TimeEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Time(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::TimeInVec(value)
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::TimeNotInVec(value)
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::TimeLt(value)
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::TimeLte(value)
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::TimeGt(value)
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::TimeGte(value)
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::TimeNot(value)
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTime(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Time(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("time").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Time(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("time").build()
            }
        }
    }
    pub mod value {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::ValueEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Value(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ValueInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ValueNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ValueLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ValueLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ValueGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ValueGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ValueContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ValueStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ValueEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ValueMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ValueNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetValue(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Value(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("value").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Value(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("value").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["id", "user_id", "time", "value"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        user_id: String,
        value: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (user_id, value, _params)
    }
    #[macro_export]
    macro_rules ! _select_login_token { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: login_token :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: login_token :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: login_token :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: login_token :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: login_token :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: login_token :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , user_id , time , value } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: login_token :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (user_id) , stringify ! (time) , stringify ! (value)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: login_token :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: login_token :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: login_token :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: login_token :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: login_token :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_id" , "time" , "value"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: login_token :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; user_id) => { String } ; (@ field_type ; time) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; value) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "LoginToken" , available fields are "id, user_id, time, value")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: login_token :: SelectParam > :: into ($ crate :: prisma :: login_token :: id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: login_token :: SelectParam > :: into ($ crate :: prisma :: login_token :: user_id :: Select) } ; (@ selection_field_to_selection_param ; time) => { Into :: < $ crate :: prisma :: login_token :: SelectParam > :: into ($ crate :: prisma :: login_token :: time :: Select) } ; (@ selection_field_to_selection_param ; value) => { Into :: < $ crate :: prisma :: login_token :: SelectParam > :: into ($ crate :: prisma :: login_token :: value :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: login_token :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; time) => { "time" } ; (@ field_serde_name ; value) => { "value" } ; }
    pub use _select_login_token as select;
    pub enum SelectParam {
        Id(id::Select),
        UserId(user_id::Select),
        Time(time::Select),
        Value(value::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Time(data) => data.to_selection(),
                Self::Value(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_login_token { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: login_token :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: login_token :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: login_token :: _outputs () ; selections . extend ($ crate :: prisma :: login_token :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: login_token :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: login_token :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: login_token :: _outputs () ; selections . extend ($ crate :: prisma :: login_token :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : String , pub user_id : String , pub time : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub value : String , $ (pub $ field : $ crate :: prisma :: login_token :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (user_id) , stringify ! (time) , stringify ! (value)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , user_id , time , value } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: login_token :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: login_token :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: login_token :: include ! (@ field_serde_name ; time) , ", " , $ crate :: prisma :: login_token :: include ! (@ field_serde_name ; value) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: login_token :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: login_token :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: login_token :: include ! (@ field_serde_name ; time) => Ok (Field :: time) , $ crate :: prisma :: login_token :: include ! (@ field_serde_name ; value) => Ok (Field :: value) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut user_id = None ; let mut time = None ; let mut value = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: time => { if time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; time))) ; } time = Some (map . next_value () ?) ; } Field :: value => { if value . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; value))) ; } value = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; id))) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; user_id))) ? ; let time = time . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; time))) ? ; let value = value . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: login_token :: include ! (@ field_serde_name ; value))) ? ; Ok (Data { id , user_id , time , value , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_id" , "time" , "value"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: login_token :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "LoginToken" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: login_token :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; time) => { "time" } ; (@ field_serde_name ; value) => { "value" } ; }
    pub use _include_login_token as include;
    pub enum IncludeParam {
        Id(id::Include),
        UserId(user_id::Include),
        Time(time::Include),
        Value(value::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Time(data) => data.to_selection(),
                Self::Value(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "user_id")]
        pub user_id: String,
        #[serde(rename = "time")]
        pub time: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "value")]
        pub value: String,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUserId(String),
        SetTime(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        SetValue(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTime(value) => (
                    "time".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetValue(value) => (
                    "value".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        Time(::prisma_client_rust::Direction),
        Value(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Time(direction) => (
                    "time".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Value(direction) => (
                    "value".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
        TimeEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        TimeInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        TimeNotInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        TimeLt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        TimeLte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        TimeGt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        TimeGte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        TimeNot(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        ValueEquals(String),
        ValueInVec(Vec<String>),
        ValueNotInVec(Vec<String>),
        ValueLt(String),
        ValueLte(String),
        ValueGt(String),
        ValueGte(String),
        ValueContains(String),
        ValueStartsWith(String),
        ValueEndsWith(String),
        ValueMode(QueryMode),
        ValueNot(String),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TimeEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "time",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::TimeInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "time",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::TimeNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "time",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::TimeLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "time",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::TimeLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "time",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::TimeGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "time",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::TimeGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "time",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::TimeNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "time",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ValueEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ValueInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ValueNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ValueLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ValueLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ValueGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ValueGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ValueContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ValueStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ValueEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ValueMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ValueNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "value",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserIdEquals(String),
        ValueEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdEquals(value) => Self::UserIdEquals(value),
                UniqueWhereParam::ValueEquals(value) => Self::ValueEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            user_id: String,
            value: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(user_id::set(user_id));
            _params.push(value::set(value));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, value, mut _params)| {
                    _params.push(user_id::set(user_id));
                    _params.push(value::set(value));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (user_id, value, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(user_id::set(user_id));
            _params.push(value::set(value));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("LoginToken", _outputs()),
                vec![],
            )
        }
    }
}
pub mod subject_progress {
    use super::_prisma::*;
    use super::*;
    pub mod subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::SubjectIs(value)
        }
        pub fn is_not(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::SubjectIsNot(value)
        }
        pub struct Fetch(pub subject_index::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_index::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Subject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(subject_index::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: subject_index::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(subject_index::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectSubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<subject_index::SelectParam>),
            Include(Vec<subject_index::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Subject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("subject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = subject_index::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<subject_index::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<subject_index::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<subject_index::SelectParam>),
            Include(Vec<subject_index::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Subject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("subject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<subject_index::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<subject_index::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::SubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::SubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::SubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::SubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::SubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::SubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::SubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSubjectId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("subject_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("subject_id").build()
            }
        }
    }
    pub mod level {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::LevelEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Level(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LevelInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LevelNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::LevelLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::LevelLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::LevelGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::LevelGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::LevelNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementLevel(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementLevel(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyLevel(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideLevel(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLevel(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Level(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("level").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Level(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("level").build()
            }
        }
    }
    pub mod skill_level {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SkillLevelEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SkillLevel(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::SkillLevelInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::SkillLevelNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::SkillLevelLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::SkillLevelLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::SkillLevelGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::SkillLevelGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::SkillLevelNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSkillLevel(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSkillLevel(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySkillLevel(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSkillLevel(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSkillLevel(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SkillLevel(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("skill_level").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SkillLevel(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("skill_level").build()
            }
        }
    }
    pub mod next_review {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::NextReviewEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::NextReview(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::NextReviewInVec(value)
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::NextReviewNotInVec(value)
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::NextReviewLt(value)
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::NextReviewLte(value)
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::NextReviewGt(value)
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::NextReviewGte(value)
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::NextReviewNot(value)
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNextReview(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::NextReview(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("next_review").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::NextReview(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("next_review").build()
            }
        }
    }
    pub mod progress_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ProgressIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ProgressId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ProgressIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ProgressIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ProgressIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ProgressIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ProgressIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ProgressIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ProgressIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ProgressIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ProgressIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ProgressIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ProgressIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetProgressId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ProgressId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("progress_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ProgressId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("progress_id").build()
            }
        }
    }
    pub mod progress {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<progress::WhereParam>) -> WhereParam {
            WhereParam::ProgressIs(value)
        }
        pub fn is_not(value: Vec<progress::WhereParam>) -> WhereParam {
            WhereParam::ProgressIsNot(value)
        }
        pub struct Fetch(pub progress::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<progress::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Progress(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(progress::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: progress::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(progress::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectProgress(value.0)
            }
        }
        pub enum Include {
            Select(Vec<progress::SelectParam>),
            Include(Vec<progress::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Progress(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("progress");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = progress::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(progress::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<progress::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<progress::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<progress::SelectParam>),
            Include(Vec<progress::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Progress(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("progress");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(progress::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<progress::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<progress::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn subject_id_progress_id<T: From<UniqueWhereParam>>(
        subject_id: i32,
        progress_id: String,
    ) -> T {
        UniqueWhereParam::SubjectIdProgressIdEquals(subject_id, progress_id).into()
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "subject_id",
            "level",
            "skill_level",
            "next_review",
            "progress_id",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        subject: super::subject_index::UniqueWhereParam,
        level: i32,
        next_review: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        progress: super::progress::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::subject_index::UniqueWhereParam,
        i32,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        super::progress::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (subject, level, next_review, progress, _params)
    }
    #[macro_export]
    macro_rules ! _select_subject_progress { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: subject_progress :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: subject_progress :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: subject_progress :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: subject_progress :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: subject_progress :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: subject_progress :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { subject , subject_id , level , skill_level , next_review , progress_id , progress } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: subject_progress :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (subject_id) , stringify ! (level) , stringify ! (skill_level) , stringify ! (next_review) , stringify ! (progress_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: subject_progress :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: subject_progress :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: subject_progress :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_progress :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_progress :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["subject" , "subject_id" , "level" , "skill_level" , "next_review" , "progress_id" , "progress"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: subject_progress :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { subject :: Data } ; (@ field_type ; subject) => { crate :: prisma :: subject_index :: Data } ; (@ field_type ; subject_id) => { i32 } ; (@ field_type ; level) => { i32 } ; (@ field_type ; skill_level) => { i32 } ; (@ field_type ; next_review) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; progress_id) => { String } ; (@ field_type ; progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { progress :: Data } ; (@ field_type ; progress) => { crate :: prisma :: progress :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "SubjectProgress" , available fields are "subject, subject_id, level, skill_level, next_review, progress_id, progress")) } ; (@ field_module ; subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: progress :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: subject :: Select :: $ selection_mode ($ crate :: prisma :: subject_index :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; subject_id) => { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: subject_id :: Select) } ; (@ selection_field_to_selection_param ; level) => { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: level :: Select) } ; (@ selection_field_to_selection_param ; skill_level) => { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: skill_level :: Select) } ; (@ selection_field_to_selection_param ; next_review) => { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: next_review :: Select) } ; (@ selection_field_to_selection_param ; progress_id) => { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: progress_id :: Select) } ; (@ selection_field_to_selection_param ; progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: progress :: Select :: $ selection_mode ($ crate :: prisma :: progress :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_progress :: SelectParam > :: into ($ crate :: prisma :: subject_progress :: progress :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: subject_progress :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; subject) => { "subject" } ; (@ field_serde_name ; subject_id) => { "subject_id" } ; (@ field_serde_name ; level) => { "level" } ; (@ field_serde_name ; skill_level) => { "skill_level" } ; (@ field_serde_name ; next_review) => { "next_review" } ; (@ field_serde_name ; progress_id) => { "progress_id" } ; (@ field_serde_name ; progress) => { "progress" } ; }
    pub use _select_subject_progress as select;
    pub enum SelectParam {
        Subject(subject::Select),
        SubjectId(subject_id::Select),
        Level(level::Select),
        SkillLevel(skill_level::Select),
        NextReview(next_review::Select),
        ProgressId(progress_id::Select),
        Progress(progress::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Subject(data) => data.to_selection(),
                Self::SubjectId(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::SkillLevel(data) => data.to_selection(),
                Self::NextReview(data) => data.to_selection(),
                Self::ProgressId(data) => data.to_selection(),
                Self::Progress(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_subject_progress { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: subject_progress :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: subject_progress :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: subject_progress :: _outputs () ; selections . extend ($ crate :: prisma :: subject_progress :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: subject_progress :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: subject_progress :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: subject_progress :: _outputs () ; selections . extend ($ crate :: prisma :: subject_progress :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { subject , progress } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub subject_id : i32 , pub level : i32 , pub skill_level : i32 , pub next_review : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub progress_id : String , $ (pub $ field : $ crate :: prisma :: subject_progress :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (subject_id) , stringify ! (level) , stringify ! (skill_level) , stringify ! (next_review) , stringify ! (progress_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , subject_id , level , skill_level , next_review , progress_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; subject_id) , ", " , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; level) , ", " , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; skill_level) , ", " , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; next_review) , ", " , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; progress_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; subject_id) => Ok (Field :: subject_id) , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; level) => Ok (Field :: level) , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; skill_level) => Ok (Field :: skill_level) , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; next_review) => Ok (Field :: next_review) , $ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; progress_id) => Ok (Field :: progress_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut subject_id = None ; let mut level = None ; let mut skill_level = None ; let mut next_review = None ; let mut progress_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: subject_id => { if subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; subject_id))) ; } subject_id = Some (map . next_value () ?) ; } Field :: level => { if level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; level))) ; } level = Some (map . next_value () ?) ; } Field :: skill_level => { if skill_level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; skill_level))) ; } skill_level = Some (map . next_value () ?) ; } Field :: next_review => { if next_review . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; next_review))) ; } next_review = Some (map . next_value () ?) ; } Field :: progress_id => { if progress_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; progress_id))) ; } progress_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; $ field))) ? ;) * let subject_id = subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; subject_id))) ? ; let level = level . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; level))) ? ; let skill_level = skill_level . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; skill_level))) ? ; let next_review = next_review . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; next_review))) ? ; let progress_id = progress_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_progress :: include ! (@ field_serde_name ; progress_id))) ? ; Ok (Data { subject_id , level , skill_level , next_review , progress_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["subject" , "subject_id" , "level" , "skill_level" , "next_review" , "progress_id" , "progress"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: subject_progress :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { subject :: Data } ; (@ field_type ; subject) => { crate :: prisma :: subject_index :: Data } ; (@ field_type ; progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { progress :: Data } ; (@ field_type ; progress) => { crate :: prisma :: progress :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SubjectProgress" , available relations are "subject, progress")) } ; (@ field_module ; subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: progress :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_progress :: IncludeParam > :: into ($ crate :: prisma :: subject_progress :: subject :: Include :: $ selection_mode ($ crate :: prisma :: subject_index :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_progress :: IncludeParam > :: into ($ crate :: prisma :: subject_progress :: subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_progress :: IncludeParam > :: into ($ crate :: prisma :: subject_progress :: progress :: Include :: $ selection_mode ($ crate :: prisma :: progress :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_progress :: IncludeParam > :: into ($ crate :: prisma :: subject_progress :: progress :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: subject_progress :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; subject) => { "subject" } ; (@ field_serde_name ; subject_id) => { "subject_id" } ; (@ field_serde_name ; level) => { "level" } ; (@ field_serde_name ; skill_level) => { "skill_level" } ; (@ field_serde_name ; next_review) => { "next_review" } ; (@ field_serde_name ; progress_id) => { "progress_id" } ; (@ field_serde_name ; progress) => { "progress" } ; }
    pub use _include_subject_progress as include;
    pub enum IncludeParam {
        Subject(subject::Include),
        SubjectId(subject_id::Include),
        Level(level::Include),
        SkillLevel(skill_level::Include),
        NextReview(next_review::Include),
        ProgressId(progress_id::Include),
        Progress(progress::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Subject(data) => data.to_selection(),
                Self::SubjectId(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::SkillLevel(data) => data.to_selection(),
                Self::NextReview(data) => data.to_selection(),
                Self::ProgressId(data) => data.to_selection(),
                Self::Progress(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "subject")]
        pub subject: Option<Box<super::subject_index::Data>>,
        #[serde(rename = "subject_id")]
        pub subject_id: i32,
        #[serde(rename = "level")]
        pub level: i32,
        #[serde(rename = "skill_level")]
        pub skill_level: i32,
        #[serde(rename = "next_review")]
        pub next_review:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "progress_id")]
        pub progress_id: String,
        #[serde(rename = "progress")]
        pub progress: Option<Box<super::progress::Data>>,
    }
    impl Data {
        pub fn subject(
            &self,
        ) -> Result<&super::subject_index::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(subject),
                ))
                .map(|v| v.as_ref())
        }
        pub fn progress(
            &self,
        ) -> Result<&super::progress::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.progress
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(progress),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Subject(super::subject_index::UniqueArgs),
        Progress(super::progress::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Subject(args) => {
                    let mut selections = super::subject_index::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("subject");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Progress(args) => {
                    let mut selections = super::progress::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("progress");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        ConnectSubject(super::subject_index::UniqueWhereParam),
        SetSubjectId(i32),
        IncrementSubjectId(i32),
        DecrementSubjectId(i32),
        MultiplySubjectId(i32),
        DivideSubjectId(i32),
        SetLevel(i32),
        IncrementLevel(i32),
        DecrementLevel(i32),
        MultiplyLevel(i32),
        DivideLevel(i32),
        SetSkillLevel(i32),
        IncrementSkillLevel(i32),
        DecrementSkillLevel(i32),
        MultiplySkillLevel(i32),
        DivideSkillLevel(i32),
        SetNextReview(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetProgressId(String),
        ConnectProgress(super::progress::UniqueWhereParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::ConnectSubject(where_param) => (
                    "subject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetSubjectId(value) => (
                    "subject_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSubjectId(value) => (
                    "subject_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSubjectId(value) => (
                    "subject_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySubjectId(value) => (
                    "subject_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSubjectId(value) => (
                    "subject_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSkillLevel(value) => (
                    "skill_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSkillLevel(value) => (
                    "skill_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSkillLevel(value) => (
                    "skill_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySkillLevel(value) => (
                    "skill_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSkillLevel(value) => (
                    "skill_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetNextReview(value) => (
                    "next_review".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetProgressId(value) => (
                    "progress_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectProgress(where_param) => (
                    "progress".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::progress::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        SubjectId(::prisma_client_rust::Direction),
        Level(::prisma_client_rust::Direction),
        SkillLevel(::prisma_client_rust::Direction),
        NextReview(::prisma_client_rust::Direction),
        ProgressId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::SubjectId(direction) => (
                    "subject_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Level(direction) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SkillLevel(direction) => (
                    "skill_level".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::NextReview(direction) => (
                    "next_review".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ProgressId(direction) => (
                    "progress_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SubjectIdProgressIdEquals(i32, String),
        SubjectIs(Vec<super::subject_index::WhereParam>),
        SubjectIsNot(Vec<super::subject_index::WhereParam>),
        SubjectIdEquals(i32),
        SubjectIdInVec(Vec<i32>),
        SubjectIdNotInVec(Vec<i32>),
        SubjectIdLt(i32),
        SubjectIdLte(i32),
        SubjectIdGt(i32),
        SubjectIdGte(i32),
        SubjectIdNot(i32),
        LevelEquals(i32),
        LevelInVec(Vec<i32>),
        LevelNotInVec(Vec<i32>),
        LevelLt(i32),
        LevelLte(i32),
        LevelGt(i32),
        LevelGte(i32),
        LevelNot(i32),
        SkillLevelEquals(i32),
        SkillLevelInVec(Vec<i32>),
        SkillLevelNotInVec(Vec<i32>),
        SkillLevelLt(i32),
        SkillLevelLte(i32),
        SkillLevelGt(i32),
        SkillLevelGte(i32),
        SkillLevelNot(i32),
        NextReviewEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        NextReviewInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        NextReviewNotInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        NextReviewLt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        NextReviewLte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        NextReviewGt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        NextReviewGte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        NextReviewNot(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ProgressIdEquals(String),
        ProgressIdInVec(Vec<String>),
        ProgressIdNotInVec(Vec<String>),
        ProgressIdLt(String),
        ProgressIdLte(String),
        ProgressIdGt(String),
        ProgressIdGte(String),
        ProgressIdContains(String),
        ProgressIdStartsWith(String),
        ProgressIdEndsWith(String),
        ProgressIdMode(QueryMode),
        ProgressIdNot(String),
        ProgressIs(Vec<super::progress::WhereParam>),
        ProgressIsNot(Vec<super::progress::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::SubjectIdProgressIdEquals(subject_id, progress_id) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "subject_id_progress_id",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![
                            (
                                "subject_id".to_string(),
                                ::prisma_client_rust::PrismaValue::Int(subject_id as i64),
                            ),
                            (
                                "progress_id".to_string(),
                                ::prisma_client_rust::PrismaValue::String(progress_id),
                            ),
                        ]),
                    )
                }
                Self::SubjectIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "subject",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SubjectIsNot(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "subject",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SubjectIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SubjectIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LevelNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LevelLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SkillLevelEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "skill_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SkillLevelInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "skill_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SkillLevelNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "skill_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SkillLevelLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "skill_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SkillLevelLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "skill_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SkillLevelGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "skill_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SkillLevelGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "skill_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SkillLevelNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "skill_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::NextReviewEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "next_review",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NextReviewInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "next_review",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::NextReviewNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "next_review",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::NextReviewLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "next_review",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NextReviewLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "next_review",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NextReviewGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "next_review",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NextReviewGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "next_review",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NextReviewNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "next_review",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ProgressIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ProgressIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ProgressIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ProgressIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "progress_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ProgressIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "progress",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ProgressIsNot(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "progress",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        SubjectIdProgressIdEquals(i32, String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SubjectIdProgressIdEquals(subject_id, progress_id) => {
                    Self::SubjectIdProgressIdEquals(subject_id, progress_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            subject: super::subject_index::UniqueWhereParam,
            level: i32,
            next_review: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            progress: super::progress::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(subject::connect(subject));
            _params.push(level::set(level));
            _params.push(next_review::set(next_review));
            _params.push(progress::connect(progress));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(
                super::subject_index::UniqueWhereParam,
                i32,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                super::progress::UniqueWhereParam,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(subject, level, next_review, progress, mut _params)| {
                    _params.push(subject::connect(subject));
                    _params.push(level::set(level));
                    _params.push(next_review::set(next_review));
                    _params.push(progress::connect(progress));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (subject, level, next_review, progress, mut _params): (
                super::subject_index::UniqueWhereParam,
                i32,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                super::progress::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(subject::connect(subject));
            _params.push(level::set(level));
            _params.push(next_review::set(next_review));
            _params.push(progress::connect(progress));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectProgress", _outputs()),
                vec![],
            )
        }
    }
}
pub mod progress {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod subject_progress {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_progress::WhereParam>) -> WhereParam {
            WhereParam::SubjectProgressSome(value)
        }
        pub fn every(value: Vec<subject_progress::WhereParam>) -> WhereParam {
            WhereParam::SubjectProgressEvery(value)
        }
        pub fn none(value: Vec<subject_progress::WhereParam>) -> WhereParam {
            WhereParam::SubjectProgressNone(value)
        }
        pub struct Fetch(pub subject_progress::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_progress::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_progress::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_progress::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::SubjectProgress(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_progress::WhereParam>) -> Fetch {
            Fetch(subject_progress::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_progress::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_progress::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectSubjectProgress(params)
        }
        pub fn set(params: Vec<subject_progress::UniqueWhereParam>) -> SetParam {
            SetParam::SetSubjectProgress(params)
        }
        pub struct Connect(pub Vec<subject_progress::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectSubjectProgress(value.0)
            }
        }
        pub enum Include {
            Select(
                subject_progress::ManyArgs,
                Vec<subject_progress::SelectParam>,
            ),
            Include(
                subject_progress::ManyArgs,
                Vec<subject_progress::IncludeParam>,
            ),
            Fetch(subject_progress::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SubjectProgress(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("subject_progress");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_progress::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_progress::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_progress::ManyArgs,
                nested_selections: Vec<subject_progress::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_progress::ManyArgs,
                nested_selections: Vec<subject_progress::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                subject_progress::ManyArgs,
                Vec<subject_progress::SelectParam>,
            ),
            Include(
                subject_progress::ManyArgs,
                Vec<subject_progress::IncludeParam>,
            ),
            Fetch(subject_progress::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SubjectProgress(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("subject_progress");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_progress::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_progress::ManyArgs,
                nested_selections: Vec<subject_progress::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_progress::ManyArgs,
                nested_selections: Vec<subject_progress::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserSome(value)
        }
        pub fn every(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserEvery(value)
        }
        pub fn none(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserNone(value)
        }
        pub struct Fetch(pub user::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: user::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.0)
            }
        }
        pub fn fetch(params: Vec<user::WhereParam>) -> Fetch {
            Fetch(user::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<user::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUser(params)
        }
        pub fn set(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::SetUser(params)
        }
        pub struct Connect(pub Vec<user::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectUser(value.0)
            }
        }
        pub enum Include {
            Select(user::ManyArgs, Vec<user::SelectParam>),
            Include(user::ManyArgs, Vec<user::IncludeParam>),
            Fetch(user::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::User(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("User");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = user::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(user::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(args: user::ManyArgs, nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user::ManyArgs,
                nested_selections: Vec<user::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(user::ManyArgs, Vec<user::SelectParam>),
            Include(user::ManyArgs, Vec<user::IncludeParam>),
            Fetch(user::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::User(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("User");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(user::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(args: user::ManyArgs, nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user::ManyArgs,
                nested_selections: Vec<user::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod current_level {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::CurrentLevelEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CurrentLevel(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::CurrentLevelInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::CurrentLevelNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::CurrentLevelLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::CurrentLevelLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::CurrentLevelGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::CurrentLevelGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::CurrentLevelNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementCurrentLevel(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementCurrentLevel(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyCurrentLevel(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideCurrentLevel(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCurrentLevel(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CurrentLevel(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("current_level").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CurrentLevel(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("current_level").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["id", "current_level"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(_params: Vec<SetParam>) -> (Vec<SetParam>) {
        (_params)
    }
    #[macro_export]
    macro_rules ! _select_progress { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: progress :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: progress :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: progress :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: progress :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: progress :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: progress :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , subject_progress , user , current_level } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: progress :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (current_level)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: progress :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: progress :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: progress :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: progress :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: progress :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "subject_progress" , "User" , "current_level"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: progress :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; subject_progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < subject_progress :: Data > } ; (@ field_type ; subject_progress) => { Vec < crate :: prisma :: subject_progress :: Data > } ; (@ field_type ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < user :: Data > } ; (@ field_type ; user) => { Vec < crate :: prisma :: user :: Data > } ; (@ field_type ; current_level) => { i32 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Progress" , available fields are "id, subject_progress, user, current_level")) } ; (@ field_module ; subject_progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_progress :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: progress :: SelectParam > :: into ($ crate :: prisma :: progress :: id :: Select) } ; (@ selection_field_to_selection_param ; subject_progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: progress :: SelectParam > :: into ($ crate :: prisma :: progress :: subject_progress :: Select :: $ selection_mode ($ crate :: prisma :: subject_progress :: ManyArgs :: new ($ crate :: prisma :: subject_progress :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_progress :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; subject_progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: progress :: SelectParam > :: into ($ crate :: prisma :: progress :: subject_progress :: Select :: Fetch ($ crate :: prisma :: subject_progress :: ManyArgs :: new ($ crate :: prisma :: subject_progress :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: progress :: SelectParam > :: into ($ crate :: prisma :: progress :: user :: Select :: $ selection_mode ($ crate :: prisma :: user :: ManyArgs :: new ($ crate :: prisma :: user :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: progress :: SelectParam > :: into ($ crate :: prisma :: progress :: user :: Select :: Fetch ($ crate :: prisma :: user :: ManyArgs :: new ($ crate :: prisma :: user :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; current_level) => { Into :: < $ crate :: prisma :: progress :: SelectParam > :: into ($ crate :: prisma :: progress :: current_level :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: progress :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; subject_progress) => { "subject_progress" } ; (@ field_serde_name ; user) => { "User" } ; (@ field_serde_name ; current_level) => { "current_level" } ; }
    pub use _select_progress as select;
    pub enum SelectParam {
        Id(id::Select),
        SubjectProgress(subject_progress::Select),
        User(user::Select),
        CurrentLevel(current_level::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SubjectProgress(data) => data.to_selection(),
                Self::User(data) => data.to_selection(),
                Self::CurrentLevel(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_progress { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: progress :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: progress :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: progress :: _outputs () ; selections . extend ($ crate :: prisma :: progress :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: progress :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: progress :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: progress :: _outputs () ; selections . extend ($ crate :: prisma :: progress :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { subject_progress , user } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : String , pub current_level : i32 , $ (pub $ field : $ crate :: prisma :: progress :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (current_level)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , current_level } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: progress :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: progress :: include ! (@ field_serde_name ; current_level) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: progress :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: progress :: include ! (@ field_serde_name ; current_level) => Ok (Field :: current_level) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut current_level = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: current_level => { if current_level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; current_level))) ; } current_level = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; id))) ? ; let current_level = current_level . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: progress :: include ! (@ field_serde_name ; current_level))) ? ; Ok (Data { id , current_level , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "subject_progress" , "User" , "current_level"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: progress :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; subject_progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < subject_progress :: Data > } ; (@ field_type ; subject_progress) => { Vec < crate :: prisma :: subject_progress :: Data > } ; (@ field_type ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < user :: Data > } ; (@ field_type ; user) => { Vec < crate :: prisma :: user :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Progress" , available relations are "subject_progress, user")) } ; (@ field_module ; subject_progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_progress :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; subject_progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: progress :: IncludeParam > :: into ($ crate :: prisma :: progress :: subject_progress :: Include :: $ selection_mode ($ crate :: prisma :: subject_progress :: ManyArgs :: new ($ crate :: prisma :: subject_progress :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_progress :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; subject_progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: progress :: IncludeParam > :: into ($ crate :: prisma :: progress :: subject_progress :: Include :: Fetch ($ crate :: prisma :: subject_progress :: ManyArgs :: new ($ crate :: prisma :: subject_progress :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: progress :: IncludeParam > :: into ($ crate :: prisma :: progress :: user :: Include :: $ selection_mode ($ crate :: prisma :: user :: ManyArgs :: new ($ crate :: prisma :: user :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: progress :: IncludeParam > :: into ($ crate :: prisma :: progress :: user :: Include :: Fetch ($ crate :: prisma :: user :: ManyArgs :: new ($ crate :: prisma :: user :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: progress :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; subject_progress) => { "subject_progress" } ; (@ field_serde_name ; user) => { "User" } ; (@ field_serde_name ; current_level) => { "current_level" } ; }
    pub use _include_progress as include;
    pub enum IncludeParam {
        Id(id::Include),
        SubjectProgress(subject_progress::Include),
        User(user::Include),
        CurrentLevel(current_level::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SubjectProgress(data) => data.to_selection(),
                Self::User(data) => data.to_selection(),
                Self::CurrentLevel(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "subject_progress")]
        pub subject_progress: Option<Vec<super::subject_progress::Data>>,
        #[serde(rename = "User")]
        pub user: Option<Vec<super::user::Data>>,
        #[serde(rename = "current_level")]
        pub current_level: i32,
    }
    impl Data {
        pub fn subject_progress(
            &self,
        ) -> Result<
            &Vec<super::subject_progress::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.subject_progress.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(subject_progress)),
            )
        }
        pub fn user(
            &self,
        ) -> Result<&Vec<super::user::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.user
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(user),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        SubjectProgress(super::subject_progress::ManyArgs),
        User(super::user::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::SubjectProgress(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_progress::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("subject_progress");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::User(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::user::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("User");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        ConnectSubjectProgress(Vec<super::subject_progress::UniqueWhereParam>),
        DisconnectSubjectProgress(Vec<super::subject_progress::UniqueWhereParam>),
        SetSubjectProgress(Vec<super::subject_progress::UniqueWhereParam>),
        ConnectUser(Vec<super::user::UniqueWhereParam>),
        DisconnectUser(Vec<super::user::UniqueWhereParam>),
        SetUser(Vec<super::user::UniqueWhereParam>),
        SetCurrentLevel(i32),
        IncrementCurrentLevel(i32),
        DecrementCurrentLevel(i32),
        MultiplyCurrentLevel(i32),
        DivideCurrentLevel(i32),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectSubjectProgress(where_params) => (
                    "subject_progress".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_progress::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectSubjectProgress(where_params) => (
                    "subject_progress".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_progress::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetSubjectProgress(where_params) => (
                    "subject_progress".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_progress::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUser(where_params) => (
                    "User".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUser(where_params) => (
                    "User".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUser(where_params) => (
                    "User".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetCurrentLevel(value) => (
                    "current_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementCurrentLevel(value) => (
                    "current_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementCurrentLevel(value) => (
                    "current_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyCurrentLevel(value) => (
                    "current_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideCurrentLevel(value) => (
                    "current_level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CurrentLevel(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CurrentLevel(direction) => (
                    "current_level".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        SubjectProgressSome(Vec<super::subject_progress::WhereParam>),
        SubjectProgressEvery(Vec<super::subject_progress::WhereParam>),
        SubjectProgressNone(Vec<super::subject_progress::WhereParam>),
        UserSome(Vec<super::user::WhereParam>),
        UserEvery(Vec<super::user::WhereParam>),
        UserNone(Vec<super::user::WhereParam>),
        CurrentLevelEquals(i32),
        CurrentLevelInVec(Vec<i32>),
        CurrentLevelNotInVec(Vec<i32>),
        CurrentLevelLt(i32),
        CurrentLevelLte(i32),
        CurrentLevelGt(i32),
        CurrentLevelGte(i32),
        CurrentLevelNot(i32),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SubjectProgressSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "subject_progress",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::SubjectProgressEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "subject_progress",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::SubjectProgressNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "subject_progress",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::UserSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "User",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "User",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "User",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CurrentLevelEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "current_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::CurrentLevelInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "current_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CurrentLevelNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "current_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CurrentLevelLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "current_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::CurrentLevelLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "current_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::CurrentLevelGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "current_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::CurrentLevelGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "current_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::CurrentLevelNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "current_level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _where,
            )
        }
        pub fn create(self, mut _params: Vec<SetParam>) -> Create<'a> {
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data.into_iter().map(|(mut _params)| _params).collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (mut _params): (Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Progress", _outputs()),
                vec![],
            )
        }
    }
}
pub mod subject_meaning {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod accepted_answer {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::AcceptedAnswerEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AcceptedAnswer(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAcceptedAnswer(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AcceptedAnswer(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("accepted_answer").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AcceptedAnswer(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("accepted_answer").build()
            }
        }
    }
    pub mod meaning {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MeaningEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Meaning(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MeaningLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MeaningLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MeaningGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MeaningGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MeaningContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MeaningStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MeaningEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::MeaningMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MeaningNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMeaning(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Meaning(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Meaning(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning").build()
            }
        }
    }
    pub mod primary {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::PrimaryEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Primary(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPrimary(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Primary(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("primary").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Primary(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("primary").build()
            }
        }
    }
    pub mod radical_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<radical_subject::WhereParam>) -> WhereParam {
            WhereParam::RadicalSubjectIs(value)
        }
        pub fn is_not(value: Vec<radical_subject::WhereParam>) -> WhereParam {
            WhereParam::RadicalSubjectIsNot(value)
        }
        pub struct Fetch(pub radical_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<radical_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::RadicalSubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(radical_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: radical_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectRadicalSubject
        }
        pub struct Connect(radical_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectRadicalSubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<radical_subject::SelectParam>),
            Include(Vec<radical_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RadicalSubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("RadicalSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = radical_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(radical_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<radical_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<radical_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<radical_subject::SelectParam>),
            Include(Vec<radical_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RadicalSubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("RadicalSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(radical_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<radical_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<radical_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod radical_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::RadicalSubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RadicalSubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::RadicalSubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::RadicalSubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRadicalSubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRadicalSubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRadicalSubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRadicalSubjectId(value)
        }
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRadicalSubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RadicalSubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("radicalSubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RadicalSubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("radicalSubjectId").build()
            }
        }
    }
    pub mod kanji_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiSubjectIs(value)
        }
        pub fn is_not(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiSubjectIsNot(value)
        }
        pub struct Fetch(pub kanji_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<kanji_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::KanjiSubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(kanji_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: kanji_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectKanjiSubject
        }
        pub struct Connect(kanji_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectKanjiSubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<kanji_subject::SelectParam>),
            Include(Vec<kanji_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiSubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("KanjiSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = kanji_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<kanji_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<kanji_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<kanji_subject::SelectParam>),
            Include(Vec<kanji_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiSubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("KanjiSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<kanji_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<kanji_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod kanji_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::KanjiSubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::KanjiSubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KanjiSubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KanjiSubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKanjiSubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKanjiSubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKanjiSubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKanjiSubjectId(value)
        }
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetKanjiSubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiSubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kanjiSubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiSubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kanjiSubjectId").build()
            }
        }
    }
    pub mod vocabulary_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabularySubjectIs(value)
        }
        pub fn is_not(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabularySubjectIsNot(value)
        }
        pub struct Fetch(pub vocabulary_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<vocabulary_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::VocabularySubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(vocabulary_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: vocabulary_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectVocabularySubject
        }
        pub struct Connect(vocabulary_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectVocabularySubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<vocabulary_subject::SelectParam>),
            Include(Vec<vocabulary_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabularySubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("VocabularySubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vocabulary_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<vocabulary_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<vocabulary_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<vocabulary_subject::SelectParam>),
            Include(Vec<vocabulary_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabularySubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("VocabularySubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<vocabulary_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<vocabulary_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod vocabulary_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::VocabularySubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementVocabularySubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementVocabularySubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyVocabularySubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideVocabularySubjectId(value)
        }
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetVocabularySubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabularySubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("vocabularySubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabularySubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("vocabularySubjectId").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "id",
            "accepted_answer",
            "meaning",
            "primary",
            "radicalSubjectId",
            "kanjiSubjectId",
            "vocabularySubjectId",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        accepted_answer: bool,
        meaning: String,
        primary: bool,
        _params: Vec<SetParam>,
    ) -> (bool, String, bool, Vec<SetParam>) {
        (accepted_answer, meaning, primary, _params)
    }
    #[macro_export]
    macro_rules ! _select_subject_meaning { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: subject_meaning :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: subject_meaning :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: subject_meaning :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: subject_meaning :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: subject_meaning :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: subject_meaning :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , accepted_answer , meaning , primary , radical_subject , radical_subject_id , kanji_subject , kanji_subject_id , vocabulary_subject , vocabulary_subject_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: subject_meaning :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (accepted_answer) , stringify ! (meaning) , stringify ! (primary) , stringify ! (radical_subject_id) , stringify ! (kanji_subject_id) , stringify ! (vocabulary_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: subject_meaning :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: subject_meaning :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: subject_meaning :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "accepted_answer" , "meaning" , "primary" , "RadicalSubject" , "radicalSubjectId" , "KanjiSubject" , "kanjiSubjectId" , "VocabularySubject" , "vocabularySubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: subject_meaning :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; accepted_answer) => { bool } ; (@ field_type ; meaning) => { String } ; (@ field_type ; primary) => { bool } ; (@ field_type ; radical_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < radical_subject :: Data > } ; (@ field_type ; radical_subject) => { Option < crate :: prisma :: radical_subject :: Data > } ; (@ field_type ; radical_subject_id) => { Option < i32 > } ; (@ field_type ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < kanji_subject :: Data > } ; (@ field_type ; kanji_subject) => { Option < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; kanji_subject_id) => { Option < i32 > } ; (@ field_type ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject) => { Option < crate :: prisma :: vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject_id) => { Option < i32 > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "SubjectMeaning" , available fields are "id, accepted_answer, meaning, primary, radical_subject, radical_subject_id, kanji_subject, kanji_subject_id, vocabulary_subject, vocabulary_subject_id")) } ; (@ field_module ; radical_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: radical_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: id :: Select) } ; (@ selection_field_to_selection_param ; accepted_answer) => { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: accepted_answer :: Select) } ; (@ selection_field_to_selection_param ; meaning) => { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: meaning :: Select) } ; (@ selection_field_to_selection_param ; primary) => { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: primary :: Select) } ; (@ selection_field_to_selection_param ; radical_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: radical_subject :: Select :: $ selection_mode ($ crate :: prisma :: radical_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; radical_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: radical_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; radical_subject_id) => { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: radical_subject_id :: Select) } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: kanji_subject :: Select :: $ selection_mode ($ crate :: prisma :: kanji_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: kanji_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; kanji_subject_id) => { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: kanji_subject_id :: Select) } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: vocabulary_subject :: Select :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: vocabulary_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; vocabulary_subject_id) => { Into :: < $ crate :: prisma :: subject_meaning :: SelectParam > :: into ($ crate :: prisma :: subject_meaning :: vocabulary_subject_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: subject_meaning :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; accepted_answer) => { "accepted_answer" } ; (@ field_serde_name ; meaning) => { "meaning" } ; (@ field_serde_name ; primary) => { "primary" } ; (@ field_serde_name ; radical_subject) => { "RadicalSubject" } ; (@ field_serde_name ; radical_subject_id) => { "radicalSubjectId" } ; (@ field_serde_name ; kanji_subject) => { "KanjiSubject" } ; (@ field_serde_name ; kanji_subject_id) => { "kanjiSubjectId" } ; (@ field_serde_name ; vocabulary_subject) => { "VocabularySubject" } ; (@ field_serde_name ; vocabulary_subject_id) => { "vocabularySubjectId" } ; }
    pub use _select_subject_meaning as select;
    pub enum SelectParam {
        Id(id::Select),
        AcceptedAnswer(accepted_answer::Select),
        Meaning(meaning::Select),
        Primary(primary::Select),
        RadicalSubject(radical_subject::Select),
        RadicalSubjectId(radical_subject_id::Select),
        KanjiSubject(kanji_subject::Select),
        KanjiSubjectId(kanji_subject_id::Select),
        VocabularySubject(vocabulary_subject::Select),
        VocabularySubjectId(vocabulary_subject_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AcceptedAnswer(data) => data.to_selection(),
                Self::Meaning(data) => data.to_selection(),
                Self::Primary(data) => data.to_selection(),
                Self::RadicalSubject(data) => data.to_selection(),
                Self::RadicalSubjectId(data) => data.to_selection(),
                Self::KanjiSubject(data) => data.to_selection(),
                Self::KanjiSubjectId(data) => data.to_selection(),
                Self::VocabularySubject(data) => data.to_selection(),
                Self::VocabularySubjectId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_subject_meaning { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: subject_meaning :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: subject_meaning :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: subject_meaning :: _outputs () ; selections . extend ($ crate :: prisma :: subject_meaning :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: subject_meaning :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: subject_meaning :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: subject_meaning :: _outputs () ; selections . extend ($ crate :: prisma :: subject_meaning :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { radical_subject , kanji_subject , vocabulary_subject } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : String , pub accepted_answer : bool , pub meaning : String , pub primary : bool , pub radical_subject_id : Option < i32 > , pub kanji_subject_id : Option < i32 > , pub vocabulary_subject_id : Option < i32 > , $ (pub $ field : $ crate :: prisma :: subject_meaning :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (accepted_answer) , stringify ! (meaning) , stringify ! (primary) , stringify ! (radical_subject_id) , stringify ! (kanji_subject_id) , stringify ! (vocabulary_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , accepted_answer , meaning , primary , radical_subject_id , kanji_subject_id , vocabulary_subject_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; accepted_answer) , ", " , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; meaning) , ", " , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; primary) , ", " , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; radical_subject_id) , ", " , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; kanji_subject_id) , ", " , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; vocabulary_subject_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; accepted_answer) => Ok (Field :: accepted_answer) , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; meaning) => Ok (Field :: meaning) , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; primary) => Ok (Field :: primary) , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; radical_subject_id) => Ok (Field :: radical_subject_id) , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; kanji_subject_id) => Ok (Field :: kanji_subject_id) , $ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; vocabulary_subject_id) => Ok (Field :: vocabulary_subject_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut accepted_answer = None ; let mut meaning = None ; let mut primary = None ; let mut radical_subject_id = None ; let mut kanji_subject_id = None ; let mut vocabulary_subject_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: accepted_answer => { if accepted_answer . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; accepted_answer))) ; } accepted_answer = Some (map . next_value () ?) ; } Field :: meaning => { if meaning . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; meaning))) ; } meaning = Some (map . next_value () ?) ; } Field :: primary => { if primary . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; primary))) ; } primary = Some (map . next_value () ?) ; } Field :: radical_subject_id => { if radical_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; radical_subject_id))) ; } radical_subject_id = Some (map . next_value () ?) ; } Field :: kanji_subject_id => { if kanji_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; kanji_subject_id))) ; } kanji_subject_id = Some (map . next_value () ?) ; } Field :: vocabulary_subject_id => { if vocabulary_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; vocabulary_subject_id))) ; } vocabulary_subject_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; id))) ? ; let accepted_answer = accepted_answer . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; accepted_answer))) ? ; let meaning = meaning . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; meaning))) ? ; let primary = primary . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; primary))) ? ; let radical_subject_id = radical_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; radical_subject_id))) ? ; let kanji_subject_id = kanji_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; kanji_subject_id))) ? ; let vocabulary_subject_id = vocabulary_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_meaning :: include ! (@ field_serde_name ; vocabulary_subject_id))) ? ; Ok (Data { id , accepted_answer , meaning , primary , radical_subject_id , kanji_subject_id , vocabulary_subject_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "accepted_answer" , "meaning" , "primary" , "RadicalSubject" , "radicalSubjectId" , "KanjiSubject" , "kanjiSubjectId" , "VocabularySubject" , "vocabularySubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: subject_meaning :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; radical_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < radical_subject :: Data > } ; (@ field_type ; radical_subject) => { Option < crate :: prisma :: radical_subject :: Data > } ; (@ field_type ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < kanji_subject :: Data > } ; (@ field_type ; kanji_subject) => { Option < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject) => { Option < crate :: prisma :: vocabulary_subject :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SubjectMeaning" , available relations are "radical_subject, kanji_subject, vocabulary_subject")) } ; (@ field_module ; radical_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: radical_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; radical_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_meaning :: IncludeParam > :: into ($ crate :: prisma :: subject_meaning :: radical_subject :: Include :: $ selection_mode ($ crate :: prisma :: radical_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; radical_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_meaning :: IncludeParam > :: into ($ crate :: prisma :: subject_meaning :: radical_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_meaning :: IncludeParam > :: into ($ crate :: prisma :: subject_meaning :: kanji_subject :: Include :: $ selection_mode ($ crate :: prisma :: kanji_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_meaning :: IncludeParam > :: into ($ crate :: prisma :: subject_meaning :: kanji_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_meaning :: IncludeParam > :: into ($ crate :: prisma :: subject_meaning :: vocabulary_subject :: Include :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_meaning :: IncludeParam > :: into ($ crate :: prisma :: subject_meaning :: vocabulary_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: subject_meaning :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; accepted_answer) => { "accepted_answer" } ; (@ field_serde_name ; meaning) => { "meaning" } ; (@ field_serde_name ; primary) => { "primary" } ; (@ field_serde_name ; radical_subject) => { "RadicalSubject" } ; (@ field_serde_name ; radical_subject_id) => { "radicalSubjectId" } ; (@ field_serde_name ; kanji_subject) => { "KanjiSubject" } ; (@ field_serde_name ; kanji_subject_id) => { "kanjiSubjectId" } ; (@ field_serde_name ; vocabulary_subject) => { "VocabularySubject" } ; (@ field_serde_name ; vocabulary_subject_id) => { "vocabularySubjectId" } ; }
    pub use _include_subject_meaning as include;
    pub enum IncludeParam {
        Id(id::Include),
        AcceptedAnswer(accepted_answer::Include),
        Meaning(meaning::Include),
        Primary(primary::Include),
        RadicalSubject(radical_subject::Include),
        RadicalSubjectId(radical_subject_id::Include),
        KanjiSubject(kanji_subject::Include),
        KanjiSubjectId(kanji_subject_id::Include),
        VocabularySubject(vocabulary_subject::Include),
        VocabularySubjectId(vocabulary_subject_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AcceptedAnswer(data) => data.to_selection(),
                Self::Meaning(data) => data.to_selection(),
                Self::Primary(data) => data.to_selection(),
                Self::RadicalSubject(data) => data.to_selection(),
                Self::RadicalSubjectId(data) => data.to_selection(),
                Self::KanjiSubject(data) => data.to_selection(),
                Self::KanjiSubjectId(data) => data.to_selection(),
                Self::VocabularySubject(data) => data.to_selection(),
                Self::VocabularySubjectId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "accepted_answer")]
        pub accepted_answer: bool,
        #[serde(rename = "meaning")]
        pub meaning: String,
        #[serde(rename = "primary")]
        pub primary: bool,
        #[serde(
            rename = "RadicalSubject",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub radical_subject: Option<Option<Box<super::radical_subject::Data>>>,
        #[serde(rename = "radicalSubjectId")]
        pub radical_subject_id: Option<i32>,
        #[serde(
            rename = "KanjiSubject",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub kanji_subject: Option<Option<Box<super::kanji_subject::Data>>>,
        #[serde(rename = "kanjiSubjectId")]
        pub kanji_subject_id: Option<i32>,
        #[serde(
            rename = "VocabularySubject",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub vocabulary_subject: Option<Option<Box<super::vocabulary_subject::Data>>>,
        #[serde(rename = "vocabularySubjectId")]
        pub vocabulary_subject_id: Option<i32>,
    }
    impl Data {
        pub fn radical_subject(
            &self,
        ) -> Result<
            Option<&super::radical_subject::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.radical_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(radical_subject),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn kanji_subject(
            &self,
        ) -> Result<
            Option<&super::kanji_subject::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.kanji_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(kanji_subject),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn vocabulary_subject(
            &self,
        ) -> Result<
            Option<&super::vocabulary_subject::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.vocabulary_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(vocabulary_subject),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        RadicalSubject(super::radical_subject::UniqueArgs),
        KanjiSubject(super::kanji_subject::UniqueArgs),
        VocabularySubject(super::vocabulary_subject::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::RadicalSubject(args) => {
                    let mut selections = super::radical_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("RadicalSubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::KanjiSubject(args) => {
                    let mut selections = super::kanji_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("KanjiSubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::VocabularySubject(args) => {
                    let mut selections = super::vocabulary_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("VocabularySubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetAcceptedAnswer(bool),
        SetMeaning(String),
        SetPrimary(bool),
        ConnectRadicalSubject(super::radical_subject::UniqueWhereParam),
        DisconnectRadicalSubject,
        SetRadicalSubjectId(Option<i32>),
        IncrementRadicalSubjectId(i32),
        DecrementRadicalSubjectId(i32),
        MultiplyRadicalSubjectId(i32),
        DivideRadicalSubjectId(i32),
        ConnectKanjiSubject(super::kanji_subject::UniqueWhereParam),
        DisconnectKanjiSubject,
        SetKanjiSubjectId(Option<i32>),
        IncrementKanjiSubjectId(i32),
        DecrementKanjiSubjectId(i32),
        MultiplyKanjiSubjectId(i32),
        DivideKanjiSubjectId(i32),
        ConnectVocabularySubject(super::vocabulary_subject::UniqueWhereParam),
        DisconnectVocabularySubject,
        SetVocabularySubjectId(Option<i32>),
        IncrementVocabularySubjectId(i32),
        DecrementVocabularySubjectId(i32),
        MultiplyVocabularySubjectId(i32),
        DivideVocabularySubjectId(i32),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetAcceptedAnswer(value) => (
                    "accepted_answer".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetMeaning(value) => (
                    "meaning".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPrimary(value) => (
                    "primary".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::ConnectRadicalSubject(where_param) => (
                    "RadicalSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::radical_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectRadicalSubject => (
                    "RadicalSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectKanjiSubject(where_param) => (
                    "KanjiSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectKanjiSubject => (
                    "KanjiSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectVocabularySubject(where_param) => (
                    "VocabularySubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::vocabulary_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectVocabularySubject => (
                    "VocabularySubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        AcceptedAnswer(::prisma_client_rust::Direction),
        Meaning(::prisma_client_rust::Direction),
        Primary(::prisma_client_rust::Direction),
        RadicalSubjectId(::prisma_client_rust::Direction),
        KanjiSubjectId(::prisma_client_rust::Direction),
        VocabularySubjectId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AcceptedAnswer(direction) => (
                    "accepted_answer".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Meaning(direction) => (
                    "meaning".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Primary(direction) => (
                    "primary".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RadicalSubjectId(direction) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::KanjiSubjectId(direction) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::VocabularySubjectId(direction) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        AcceptedAnswerEquals(bool),
        MeaningEquals(String),
        MeaningInVec(Vec<String>),
        MeaningNotInVec(Vec<String>),
        MeaningLt(String),
        MeaningLte(String),
        MeaningGt(String),
        MeaningGte(String),
        MeaningContains(String),
        MeaningStartsWith(String),
        MeaningEndsWith(String),
        MeaningMode(QueryMode),
        MeaningNot(String),
        PrimaryEquals(bool),
        RadicalSubjectIs(Vec<super::radical_subject::WhereParam>),
        RadicalSubjectIsNot(Vec<super::radical_subject::WhereParam>),
        RadicalSubjectIdEquals(Option<i32>),
        RadicalSubjectIdInVec(Vec<i32>),
        RadicalSubjectIdNotInVec(Vec<i32>),
        RadicalSubjectIdLt(i32),
        RadicalSubjectIdLte(i32),
        RadicalSubjectIdGt(i32),
        RadicalSubjectIdGte(i32),
        RadicalSubjectIdNot(i32),
        KanjiSubjectIs(Vec<super::kanji_subject::WhereParam>),
        KanjiSubjectIsNot(Vec<super::kanji_subject::WhereParam>),
        KanjiSubjectIdEquals(Option<i32>),
        KanjiSubjectIdInVec(Vec<i32>),
        KanjiSubjectIdNotInVec(Vec<i32>),
        KanjiSubjectIdLt(i32),
        KanjiSubjectIdLte(i32),
        KanjiSubjectIdGt(i32),
        KanjiSubjectIdGte(i32),
        KanjiSubjectIdNot(i32),
        VocabularySubjectIs(Vec<super::vocabulary_subject::WhereParam>),
        VocabularySubjectIsNot(Vec<super::vocabulary_subject::WhereParam>),
        VocabularySubjectIdEquals(Option<i32>),
        VocabularySubjectIdInVec(Vec<i32>),
        VocabularySubjectIdNotInVec(Vec<i32>),
        VocabularySubjectIdLt(i32),
        VocabularySubjectIdLte(i32),
        VocabularySubjectIdGt(i32),
        VocabularySubjectIdGte(i32),
        VocabularySubjectIdNot(i32),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AcceptedAnswerEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "accepted_answer",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::MeaningEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::MeaningNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PrimaryEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "primary",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::RadicalSubjectIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "RadicalSubject",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RadicalSubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "RadicalSubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::RadicalSubjectIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::RadicalSubjectIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::RadicalSubjectIdNotInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "radicalSubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::RadicalSubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalSubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalSubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalSubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalSubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "KanjiSubject",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "KanjiSubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::KanjiSubjectIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::KanjiSubjectIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIs(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "VocabularySubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "is".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "VocabularySubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdEquals(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                        )]),
                    )
                }
                Self::VocabularySubjectIdInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdNotInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            accepted_answer: bool,
            meaning: String,
            primary: bool,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(accepted_answer::set(accepted_answer));
            _params.push(meaning::set(meaning));
            _params.push(primary::set(primary));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(bool, String, bool, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(accepted_answer, meaning, primary, mut _params)| {
                    _params.push(accepted_answer::set(accepted_answer));
                    _params.push(meaning::set(meaning));
                    _params.push(primary::set(primary));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (accepted_answer, meaning, primary, mut _params): (bool, String, bool, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(accepted_answer::set(accepted_answer));
            _params.push(meaning::set(meaning));
            _params.push(primary::set(primary));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectMeaning", _outputs()),
                vec![],
            )
        }
    }
}
pub mod auxiliary_meaning {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod meaning {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MeaningEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Meaning(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MeaningLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MeaningLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MeaningGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MeaningGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MeaningContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MeaningStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MeaningEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::MeaningMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MeaningNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMeaning(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Meaning(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Meaning(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning").build()
            }
        }
    }
    pub mod auxiliary_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AuxiliaryType(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AuxiliaryTypeInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AuxiliaryTypeNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AuxiliaryTypeMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AuxiliaryTypeNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAuxiliaryType(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AuxiliaryType(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("auxiliary_type").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AuxiliaryType(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("auxiliary_type").build()
            }
        }
    }
    pub mod radical_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<radical_subject::WhereParam>) -> WhereParam {
            WhereParam::RadicalSubjectIs(value)
        }
        pub fn is_not(value: Vec<radical_subject::WhereParam>) -> WhereParam {
            WhereParam::RadicalSubjectIsNot(value)
        }
        pub struct Fetch(pub radical_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<radical_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::RadicalSubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(radical_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: radical_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectRadicalSubject
        }
        pub struct Connect(radical_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectRadicalSubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<radical_subject::SelectParam>),
            Include(Vec<radical_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RadicalSubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("RadicalSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = radical_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(radical_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<radical_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<radical_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<radical_subject::SelectParam>),
            Include(Vec<radical_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RadicalSubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("RadicalSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(radical_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<radical_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<radical_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod radical_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::RadicalSubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RadicalSubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::RadicalSubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::RadicalSubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::RadicalSubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRadicalSubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRadicalSubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRadicalSubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRadicalSubjectId(value)
        }
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRadicalSubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RadicalSubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("radicalSubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RadicalSubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("radicalSubjectId").build()
            }
        }
    }
    pub mod kanji_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiSubjectIs(value)
        }
        pub fn is_not(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiSubjectIsNot(value)
        }
        pub struct Fetch(pub kanji_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<kanji_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::KanjiSubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(kanji_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: kanji_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectKanjiSubject
        }
        pub struct Connect(kanji_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectKanjiSubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<kanji_subject::SelectParam>),
            Include(Vec<kanji_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiSubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("KanjiSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = kanji_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<kanji_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<kanji_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<kanji_subject::SelectParam>),
            Include(Vec<kanji_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiSubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("KanjiSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<kanji_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<kanji_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod kanji_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::KanjiSubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::KanjiSubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KanjiSubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KanjiSubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKanjiSubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKanjiSubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKanjiSubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKanjiSubjectId(value)
        }
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetKanjiSubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiSubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kanjiSubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiSubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kanjiSubjectId").build()
            }
        }
    }
    pub mod vocabulary_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabularySubjectIs(value)
        }
        pub fn is_not(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabularySubjectIsNot(value)
        }
        pub struct Fetch(pub vocabulary_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<vocabulary_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::VocabularySubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(vocabulary_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: vocabulary_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectVocabularySubject
        }
        pub struct Connect(vocabulary_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectVocabularySubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<vocabulary_subject::SelectParam>),
            Include(Vec<vocabulary_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabularySubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("VocabularySubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vocabulary_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<vocabulary_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<vocabulary_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<vocabulary_subject::SelectParam>),
            Include(Vec<vocabulary_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabularySubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("VocabularySubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<vocabulary_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<vocabulary_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod vocabulary_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::VocabularySubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementVocabularySubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementVocabularySubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyVocabularySubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideVocabularySubjectId(value)
        }
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetVocabularySubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabularySubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("vocabularySubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabularySubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("vocabularySubjectId").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "id",
            "meaning",
            "auxiliary_type",
            "radicalSubjectId",
            "kanjiSubjectId",
            "vocabularySubjectId",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        meaning: String,
        auxiliary_type: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (meaning, auxiliary_type, _params)
    }
    #[macro_export]
    macro_rules ! _select_auxiliary_meaning { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: auxiliary_meaning :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: auxiliary_meaning :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: auxiliary_meaning :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: auxiliary_meaning :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: auxiliary_meaning :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: auxiliary_meaning :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , meaning , auxiliary_type , radical_subject , radical_subject_id , kanji_subject , kanji_subject_id , vocabulary_subject , vocabulary_subject_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: auxiliary_meaning :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (meaning) , stringify ! (auxiliary_type) , stringify ! (radical_subject_id) , stringify ! (kanji_subject_id) , stringify ! (vocabulary_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: auxiliary_meaning :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: auxiliary_meaning :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: auxiliary_meaning :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: auxiliary_meaning :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: auxiliary_meaning :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "meaning" , "auxiliary_type" , "RadicalSubject" , "radicalSubjectId" , "KanjiSubject" , "kanjiSubjectId" , "VocabularySubject" , "vocabularySubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: auxiliary_meaning :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; meaning) => { String } ; (@ field_type ; auxiliary_type) => { String } ; (@ field_type ; radical_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < radical_subject :: Data > } ; (@ field_type ; radical_subject) => { Option < crate :: prisma :: radical_subject :: Data > } ; (@ field_type ; radical_subject_id) => { Option < i32 > } ; (@ field_type ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < kanji_subject :: Data > } ; (@ field_type ; kanji_subject) => { Option < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; kanji_subject_id) => { Option < i32 > } ; (@ field_type ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject) => { Option < crate :: prisma :: vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject_id) => { Option < i32 > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "AuxiliaryMeaning" , available fields are "id, meaning, auxiliary_type, radical_subject, radical_subject_id, kanji_subject, kanji_subject_id, vocabulary_subject, vocabulary_subject_id")) } ; (@ field_module ; radical_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: radical_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: id :: Select) } ; (@ selection_field_to_selection_param ; meaning) => { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: meaning :: Select) } ; (@ selection_field_to_selection_param ; auxiliary_type) => { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: auxiliary_type :: Select) } ; (@ selection_field_to_selection_param ; radical_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: radical_subject :: Select :: $ selection_mode ($ crate :: prisma :: radical_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; radical_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: radical_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; radical_subject_id) => { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: radical_subject_id :: Select) } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: kanji_subject :: Select :: $ selection_mode ($ crate :: prisma :: kanji_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: kanji_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; kanji_subject_id) => { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: kanji_subject_id :: Select) } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: vocabulary_subject :: Select :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: vocabulary_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; vocabulary_subject_id) => { Into :: < $ crate :: prisma :: auxiliary_meaning :: SelectParam > :: into ($ crate :: prisma :: auxiliary_meaning :: vocabulary_subject_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: auxiliary_meaning :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; meaning) => { "meaning" } ; (@ field_serde_name ; auxiliary_type) => { "auxiliary_type" } ; (@ field_serde_name ; radical_subject) => { "RadicalSubject" } ; (@ field_serde_name ; radical_subject_id) => { "radicalSubjectId" } ; (@ field_serde_name ; kanji_subject) => { "KanjiSubject" } ; (@ field_serde_name ; kanji_subject_id) => { "kanjiSubjectId" } ; (@ field_serde_name ; vocabulary_subject) => { "VocabularySubject" } ; (@ field_serde_name ; vocabulary_subject_id) => { "vocabularySubjectId" } ; }
    pub use _select_auxiliary_meaning as select;
    pub enum SelectParam {
        Id(id::Select),
        Meaning(meaning::Select),
        AuxiliaryType(auxiliary_type::Select),
        RadicalSubject(radical_subject::Select),
        RadicalSubjectId(radical_subject_id::Select),
        KanjiSubject(kanji_subject::Select),
        KanjiSubjectId(kanji_subject_id::Select),
        VocabularySubject(vocabulary_subject::Select),
        VocabularySubjectId(vocabulary_subject_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Meaning(data) => data.to_selection(),
                Self::AuxiliaryType(data) => data.to_selection(),
                Self::RadicalSubject(data) => data.to_selection(),
                Self::RadicalSubjectId(data) => data.to_selection(),
                Self::KanjiSubject(data) => data.to_selection(),
                Self::KanjiSubjectId(data) => data.to_selection(),
                Self::VocabularySubject(data) => data.to_selection(),
                Self::VocabularySubjectId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_auxiliary_meaning { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: auxiliary_meaning :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: auxiliary_meaning :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: auxiliary_meaning :: _outputs () ; selections . extend ($ crate :: prisma :: auxiliary_meaning :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: auxiliary_meaning :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: auxiliary_meaning :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: auxiliary_meaning :: _outputs () ; selections . extend ($ crate :: prisma :: auxiliary_meaning :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { radical_subject , kanji_subject , vocabulary_subject } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : String , pub meaning : String , pub auxiliary_type : String , pub radical_subject_id : Option < i32 > , pub kanji_subject_id : Option < i32 > , pub vocabulary_subject_id : Option < i32 > , $ (pub $ field : $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (meaning) , stringify ! (auxiliary_type) , stringify ! (radical_subject_id) , stringify ! (kanji_subject_id) , stringify ! (vocabulary_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , meaning , auxiliary_type , radical_subject_id , kanji_subject_id , vocabulary_subject_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; meaning) , ", " , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; auxiliary_type) , ", " , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; radical_subject_id) , ", " , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; kanji_subject_id) , ", " , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; vocabulary_subject_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; meaning) => Ok (Field :: meaning) , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; auxiliary_type) => Ok (Field :: auxiliary_type) , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; radical_subject_id) => Ok (Field :: radical_subject_id) , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; kanji_subject_id) => Ok (Field :: kanji_subject_id) , $ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; vocabulary_subject_id) => Ok (Field :: vocabulary_subject_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut meaning = None ; let mut auxiliary_type = None ; let mut radical_subject_id = None ; let mut kanji_subject_id = None ; let mut vocabulary_subject_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: meaning => { if meaning . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; meaning))) ; } meaning = Some (map . next_value () ?) ; } Field :: auxiliary_type => { if auxiliary_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; auxiliary_type))) ; } auxiliary_type = Some (map . next_value () ?) ; } Field :: radical_subject_id => { if radical_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; radical_subject_id))) ; } radical_subject_id = Some (map . next_value () ?) ; } Field :: kanji_subject_id => { if kanji_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; kanji_subject_id))) ; } kanji_subject_id = Some (map . next_value () ?) ; } Field :: vocabulary_subject_id => { if vocabulary_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; vocabulary_subject_id))) ; } vocabulary_subject_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; id))) ? ; let meaning = meaning . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; meaning))) ? ; let auxiliary_type = auxiliary_type . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; auxiliary_type))) ? ; let radical_subject_id = radical_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; radical_subject_id))) ? ; let kanji_subject_id = kanji_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; kanji_subject_id))) ? ; let vocabulary_subject_id = vocabulary_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: auxiliary_meaning :: include ! (@ field_serde_name ; vocabulary_subject_id))) ? ; Ok (Data { id , meaning , auxiliary_type , radical_subject_id , kanji_subject_id , vocabulary_subject_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "meaning" , "auxiliary_type" , "RadicalSubject" , "radicalSubjectId" , "KanjiSubject" , "kanjiSubjectId" , "VocabularySubject" , "vocabularySubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: auxiliary_meaning :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; radical_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < radical_subject :: Data > } ; (@ field_type ; radical_subject) => { Option < crate :: prisma :: radical_subject :: Data > } ; (@ field_type ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < kanji_subject :: Data > } ; (@ field_type ; kanji_subject) => { Option < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject) => { Option < crate :: prisma :: vocabulary_subject :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "AuxiliaryMeaning" , available relations are "radical_subject, kanji_subject, vocabulary_subject")) } ; (@ field_module ; radical_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: radical_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; radical_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: IncludeParam > :: into ($ crate :: prisma :: auxiliary_meaning :: radical_subject :: Include :: $ selection_mode ($ crate :: prisma :: radical_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; radical_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: IncludeParam > :: into ($ crate :: prisma :: auxiliary_meaning :: radical_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: IncludeParam > :: into ($ crate :: prisma :: auxiliary_meaning :: kanji_subject :: Include :: $ selection_mode ($ crate :: prisma :: kanji_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: IncludeParam > :: into ($ crate :: prisma :: auxiliary_meaning :: kanji_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: IncludeParam > :: into ($ crate :: prisma :: auxiliary_meaning :: vocabulary_subject :: Include :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: auxiliary_meaning :: IncludeParam > :: into ($ crate :: prisma :: auxiliary_meaning :: vocabulary_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: auxiliary_meaning :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; meaning) => { "meaning" } ; (@ field_serde_name ; auxiliary_type) => { "auxiliary_type" } ; (@ field_serde_name ; radical_subject) => { "RadicalSubject" } ; (@ field_serde_name ; radical_subject_id) => { "radicalSubjectId" } ; (@ field_serde_name ; kanji_subject) => { "KanjiSubject" } ; (@ field_serde_name ; kanji_subject_id) => { "kanjiSubjectId" } ; (@ field_serde_name ; vocabulary_subject) => { "VocabularySubject" } ; (@ field_serde_name ; vocabulary_subject_id) => { "vocabularySubjectId" } ; }
    pub use _include_auxiliary_meaning as include;
    pub enum IncludeParam {
        Id(id::Include),
        Meaning(meaning::Include),
        AuxiliaryType(auxiliary_type::Include),
        RadicalSubject(radical_subject::Include),
        RadicalSubjectId(radical_subject_id::Include),
        KanjiSubject(kanji_subject::Include),
        KanjiSubjectId(kanji_subject_id::Include),
        VocabularySubject(vocabulary_subject::Include),
        VocabularySubjectId(vocabulary_subject_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Meaning(data) => data.to_selection(),
                Self::AuxiliaryType(data) => data.to_selection(),
                Self::RadicalSubject(data) => data.to_selection(),
                Self::RadicalSubjectId(data) => data.to_selection(),
                Self::KanjiSubject(data) => data.to_selection(),
                Self::KanjiSubjectId(data) => data.to_selection(),
                Self::VocabularySubject(data) => data.to_selection(),
                Self::VocabularySubjectId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "meaning")]
        pub meaning: String,
        #[serde(rename = "auxiliary_type")]
        pub auxiliary_type: String,
        #[serde(
            rename = "RadicalSubject",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub radical_subject: Option<Option<Box<super::radical_subject::Data>>>,
        #[serde(rename = "radicalSubjectId")]
        pub radical_subject_id: Option<i32>,
        #[serde(
            rename = "KanjiSubject",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub kanji_subject: Option<Option<Box<super::kanji_subject::Data>>>,
        #[serde(rename = "kanjiSubjectId")]
        pub kanji_subject_id: Option<i32>,
        #[serde(
            rename = "VocabularySubject",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub vocabulary_subject: Option<Option<Box<super::vocabulary_subject::Data>>>,
        #[serde(rename = "vocabularySubjectId")]
        pub vocabulary_subject_id: Option<i32>,
    }
    impl Data {
        pub fn radical_subject(
            &self,
        ) -> Result<
            Option<&super::radical_subject::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.radical_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(radical_subject),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn kanji_subject(
            &self,
        ) -> Result<
            Option<&super::kanji_subject::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.kanji_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(kanji_subject),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn vocabulary_subject(
            &self,
        ) -> Result<
            Option<&super::vocabulary_subject::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.vocabulary_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(vocabulary_subject),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        RadicalSubject(super::radical_subject::UniqueArgs),
        KanjiSubject(super::kanji_subject::UniqueArgs),
        VocabularySubject(super::vocabulary_subject::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::RadicalSubject(args) => {
                    let mut selections = super::radical_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("RadicalSubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::KanjiSubject(args) => {
                    let mut selections = super::kanji_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("KanjiSubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::VocabularySubject(args) => {
                    let mut selections = super::vocabulary_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("VocabularySubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetMeaning(String),
        SetAuxiliaryType(String),
        ConnectRadicalSubject(super::radical_subject::UniqueWhereParam),
        DisconnectRadicalSubject,
        SetRadicalSubjectId(Option<i32>),
        IncrementRadicalSubjectId(i32),
        DecrementRadicalSubjectId(i32),
        MultiplyRadicalSubjectId(i32),
        DivideRadicalSubjectId(i32),
        ConnectKanjiSubject(super::kanji_subject::UniqueWhereParam),
        DisconnectKanjiSubject,
        SetKanjiSubjectId(Option<i32>),
        IncrementKanjiSubjectId(i32),
        DecrementKanjiSubjectId(i32),
        MultiplyKanjiSubjectId(i32),
        DivideKanjiSubjectId(i32),
        ConnectVocabularySubject(super::vocabulary_subject::UniqueWhereParam),
        DisconnectVocabularySubject,
        SetVocabularySubjectId(Option<i32>),
        IncrementVocabularySubjectId(i32),
        DecrementVocabularySubjectId(i32),
        MultiplyVocabularySubjectId(i32),
        DivideVocabularySubjectId(i32),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMeaning(value) => (
                    "meaning".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetAuxiliaryType(value) => (
                    "auxiliary_type".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectRadicalSubject(where_param) => (
                    "RadicalSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::radical_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectRadicalSubject => (
                    "RadicalSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRadicalSubjectId(value) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectKanjiSubject(where_param) => (
                    "KanjiSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectKanjiSubject => (
                    "KanjiSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectVocabularySubject(where_param) => (
                    "VocabularySubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::vocabulary_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectVocabularySubject => (
                    "VocabularySubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Meaning(::prisma_client_rust::Direction),
        AuxiliaryType(::prisma_client_rust::Direction),
        RadicalSubjectId(::prisma_client_rust::Direction),
        KanjiSubjectId(::prisma_client_rust::Direction),
        VocabularySubjectId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Meaning(direction) => (
                    "meaning".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AuxiliaryType(direction) => (
                    "auxiliary_type".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RadicalSubjectId(direction) => (
                    "radicalSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::KanjiSubjectId(direction) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::VocabularySubjectId(direction) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        MeaningEquals(String),
        MeaningInVec(Vec<String>),
        MeaningNotInVec(Vec<String>),
        MeaningLt(String),
        MeaningLte(String),
        MeaningGt(String),
        MeaningGte(String),
        MeaningContains(String),
        MeaningStartsWith(String),
        MeaningEndsWith(String),
        MeaningMode(QueryMode),
        MeaningNot(String),
        AuxiliaryTypeEquals(String),
        AuxiliaryTypeInVec(Vec<String>),
        AuxiliaryTypeNotInVec(Vec<String>),
        AuxiliaryTypeLt(String),
        AuxiliaryTypeLte(String),
        AuxiliaryTypeGt(String),
        AuxiliaryTypeGte(String),
        AuxiliaryTypeContains(String),
        AuxiliaryTypeStartsWith(String),
        AuxiliaryTypeEndsWith(String),
        AuxiliaryTypeMode(QueryMode),
        AuxiliaryTypeNot(String),
        RadicalSubjectIs(Vec<super::radical_subject::WhereParam>),
        RadicalSubjectIsNot(Vec<super::radical_subject::WhereParam>),
        RadicalSubjectIdEquals(Option<i32>),
        RadicalSubjectIdInVec(Vec<i32>),
        RadicalSubjectIdNotInVec(Vec<i32>),
        RadicalSubjectIdLt(i32),
        RadicalSubjectIdLte(i32),
        RadicalSubjectIdGt(i32),
        RadicalSubjectIdGte(i32),
        RadicalSubjectIdNot(i32),
        KanjiSubjectIs(Vec<super::kanji_subject::WhereParam>),
        KanjiSubjectIsNot(Vec<super::kanji_subject::WhereParam>),
        KanjiSubjectIdEquals(Option<i32>),
        KanjiSubjectIdInVec(Vec<i32>),
        KanjiSubjectIdNotInVec(Vec<i32>),
        KanjiSubjectIdLt(i32),
        KanjiSubjectIdLte(i32),
        KanjiSubjectIdGt(i32),
        KanjiSubjectIdGte(i32),
        KanjiSubjectIdNot(i32),
        VocabularySubjectIs(Vec<super::vocabulary_subject::WhereParam>),
        VocabularySubjectIsNot(Vec<super::vocabulary_subject::WhereParam>),
        VocabularySubjectIdEquals(Option<i32>),
        VocabularySubjectIdInVec(Vec<i32>),
        VocabularySubjectIdNotInVec(Vec<i32>),
        VocabularySubjectIdLt(i32),
        VocabularySubjectIdLte(i32),
        VocabularySubjectIdGt(i32),
        VocabularySubjectIdGte(i32),
        VocabularySubjectIdNot(i32),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::MeaningNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuxiliaryTypeNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuxiliaryTypeLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuxiliaryTypeMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AuxiliaryTypeNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "auxiliary_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::RadicalSubjectIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "RadicalSubject",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RadicalSubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "RadicalSubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::RadicalSubjectIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::RadicalSubjectIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::RadicalSubjectIdNotInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "radicalSubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::RadicalSubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalSubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalSubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalSubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalSubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "radicalSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "KanjiSubject",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "KanjiSubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::KanjiSubjectIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::KanjiSubjectIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIs(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "VocabularySubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "is".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "VocabularySubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdEquals(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                        )]),
                    )
                }
                Self::VocabularySubjectIdInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdNotInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            meaning: String,
            auxiliary_type: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(meaning::set(meaning));
            _params.push(auxiliary_type::set(auxiliary_type));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(meaning, auxiliary_type, mut _params)| {
                    _params.push(meaning::set(meaning));
                    _params.push(auxiliary_type::set(auxiliary_type));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (meaning, auxiliary_type, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(meaning::set(meaning));
            _params.push(auxiliary_type::set(auxiliary_type));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("AuxiliaryMeaning", _outputs()),
                vec![],
            )
        }
    }
}
pub mod kanji_reading {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod reading {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ReadingEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Reading(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ReadingLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ReadingLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ReadingGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ReadingGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ReadingContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ReadingStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ReadingEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ReadingMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ReadingNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReading(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reading(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reading(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading").build()
            }
        }
    }
    pub mod reading_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ReadingType) -> T {
            Set(value).into()
        }
        pub fn equals(value: ReadingType) -> WhereParam {
            WhereParam::ReadingTypeEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReadingType(direction)
        }
        pub struct Set(pub ReadingType);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReadingType(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReadingType(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading_type").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReadingType(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading_type").build()
            }
        }
    }
    pub mod primary {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::PrimaryEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Primary(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPrimary(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Primary(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("primary").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Primary(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("primary").build()
            }
        }
    }
    pub mod kanji_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiSubjectIs(value)
        }
        pub fn is_not(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiSubjectIsNot(value)
        }
        pub struct Fetch(pub kanji_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<kanji_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::KanjiSubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(kanji_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: kanji_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(kanji_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectKanjiSubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<kanji_subject::SelectParam>),
            Include(Vec<kanji_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiSubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("KanjiSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = kanji_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<kanji_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<kanji_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<kanji_subject::SelectParam>),
            Include(Vec<kanji_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiSubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("KanjiSubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<kanji_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<kanji_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod kanji_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::KanjiSubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KanjiSubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KanjiSubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::KanjiSubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKanjiSubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKanjiSubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKanjiSubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKanjiSubjectId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetKanjiSubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiSubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kanjiSubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiSubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kanjiSubjectId").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["id", "reading", "reading_type", "primary", "kanjiSubjectId"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        reading: String,
        reading_type: ReadingType,
        primary: bool,
        kanji_subject: super::kanji_subject::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        ReadingType,
        bool,
        super::kanji_subject::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (reading, reading_type, primary, kanji_subject, _params)
    }
    #[macro_export]
    macro_rules ! _select_kanji_reading { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: kanji_reading :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: kanji_reading :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: kanji_reading :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: kanji_reading :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: kanji_reading :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: kanji_reading :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , reading , reading_type , primary , kanji_subject , kanji_subject_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: kanji_reading :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (reading) , stringify ! (reading_type) , stringify ! (primary) , stringify ! (kanji_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: kanji_reading :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: kanji_reading :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: kanji_reading :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_reading :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_reading :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "reading" , "reading_type" , "primary" , "KanjiSubject" , "kanjiSubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: kanji_reading :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; reading) => { String } ; (@ field_type ; reading_type) => { ReadingType } ; (@ field_type ; primary) => { bool } ; (@ field_type ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { kanji_subject :: Data } ; (@ field_type ; kanji_subject) => { crate :: prisma :: kanji_subject :: Data } ; (@ field_type ; kanji_subject_id) => { i32 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "KanjiReading" , available fields are "id, reading, reading_type, primary, kanji_subject, kanji_subject_id")) } ; (@ field_module ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: kanji_reading :: SelectParam > :: into ($ crate :: prisma :: kanji_reading :: id :: Select) } ; (@ selection_field_to_selection_param ; reading) => { Into :: < $ crate :: prisma :: kanji_reading :: SelectParam > :: into ($ crate :: prisma :: kanji_reading :: reading :: Select) } ; (@ selection_field_to_selection_param ; reading_type) => { Into :: < $ crate :: prisma :: kanji_reading :: SelectParam > :: into ($ crate :: prisma :: kanji_reading :: reading_type :: Select) } ; (@ selection_field_to_selection_param ; primary) => { Into :: < $ crate :: prisma :: kanji_reading :: SelectParam > :: into ($ crate :: prisma :: kanji_reading :: primary :: Select) } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_reading :: SelectParam > :: into ($ crate :: prisma :: kanji_reading :: kanji_subject :: Select :: $ selection_mode ($ crate :: prisma :: kanji_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_reading :: SelectParam > :: into ($ crate :: prisma :: kanji_reading :: kanji_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; kanji_subject_id) => { Into :: < $ crate :: prisma :: kanji_reading :: SelectParam > :: into ($ crate :: prisma :: kanji_reading :: kanji_subject_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: kanji_reading :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; reading) => { "reading" } ; (@ field_serde_name ; reading_type) => { "reading_type" } ; (@ field_serde_name ; primary) => { "primary" } ; (@ field_serde_name ; kanji_subject) => { "KanjiSubject" } ; (@ field_serde_name ; kanji_subject_id) => { "kanjiSubjectId" } ; }
    pub use _select_kanji_reading as select;
    pub enum SelectParam {
        Id(id::Select),
        Reading(reading::Select),
        ReadingType(reading_type::Select),
        Primary(primary::Select),
        KanjiSubject(kanji_subject::Select),
        KanjiSubjectId(kanji_subject_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Reading(data) => data.to_selection(),
                Self::ReadingType(data) => data.to_selection(),
                Self::Primary(data) => data.to_selection(),
                Self::KanjiSubject(data) => data.to_selection(),
                Self::KanjiSubjectId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_kanji_reading { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: kanji_reading :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: kanji_reading :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: kanji_reading :: _outputs () ; selections . extend ($ crate :: prisma :: kanji_reading :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: kanji_reading :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: kanji_reading :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: kanji_reading :: _outputs () ; selections . extend ($ crate :: prisma :: kanji_reading :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { kanji_subject } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : String , pub reading : String , pub reading_type : ReadingType , pub primary : bool , pub kanji_subject_id : i32 , $ (pub $ field : $ crate :: prisma :: kanji_reading :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (reading) , stringify ! (reading_type) , stringify ! (primary) , stringify ! (kanji_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , reading , reading_type , primary , kanji_subject_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; reading) , ", " , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; reading_type) , ", " , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; primary) , ", " , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; kanji_subject_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; reading) => Ok (Field :: reading) , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; reading_type) => Ok (Field :: reading_type) , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; primary) => Ok (Field :: primary) , $ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; kanji_subject_id) => Ok (Field :: kanji_subject_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut reading = None ; let mut reading_type = None ; let mut primary = None ; let mut kanji_subject_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: reading => { if reading . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; reading))) ; } reading = Some (map . next_value () ?) ; } Field :: reading_type => { if reading_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; reading_type))) ; } reading_type = Some (map . next_value () ?) ; } Field :: primary => { if primary . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; primary))) ; } primary = Some (map . next_value () ?) ; } Field :: kanji_subject_id => { if kanji_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; kanji_subject_id))) ; } kanji_subject_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; id))) ? ; let reading = reading . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; reading))) ? ; let reading_type = reading_type . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; reading_type))) ? ; let primary = primary . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; primary))) ? ; let kanji_subject_id = kanji_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_reading :: include ! (@ field_serde_name ; kanji_subject_id))) ? ; Ok (Data { id , reading , reading_type , primary , kanji_subject_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "reading" , "reading_type" , "primary" , "KanjiSubject" , "kanjiSubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: kanji_reading :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { kanji_subject :: Data } ; (@ field_type ; kanji_subject) => { crate :: prisma :: kanji_subject :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "KanjiReading" , available relations are "kanji_subject")) } ; (@ field_module ; kanji_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_reading :: IncludeParam > :: into ($ crate :: prisma :: kanji_reading :: kanji_subject :: Include :: $ selection_mode ($ crate :: prisma :: kanji_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_reading :: IncludeParam > :: into ($ crate :: prisma :: kanji_reading :: kanji_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: kanji_reading :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; reading) => { "reading" } ; (@ field_serde_name ; reading_type) => { "reading_type" } ; (@ field_serde_name ; primary) => { "primary" } ; (@ field_serde_name ; kanji_subject) => { "KanjiSubject" } ; (@ field_serde_name ; kanji_subject_id) => { "kanjiSubjectId" } ; }
    pub use _include_kanji_reading as include;
    pub enum IncludeParam {
        Id(id::Include),
        Reading(reading::Include),
        ReadingType(reading_type::Include),
        Primary(primary::Include),
        KanjiSubject(kanji_subject::Include),
        KanjiSubjectId(kanji_subject_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Reading(data) => data.to_selection(),
                Self::ReadingType(data) => data.to_selection(),
                Self::Primary(data) => data.to_selection(),
                Self::KanjiSubject(data) => data.to_selection(),
                Self::KanjiSubjectId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "reading")]
        pub reading: String,
        #[serde(rename = "reading_type")]
        pub reading_type: ReadingType,
        #[serde(rename = "primary")]
        pub primary: bool,
        #[serde(rename = "KanjiSubject")]
        pub kanji_subject: Option<Box<super::kanji_subject::Data>>,
        #[serde(rename = "kanjiSubjectId")]
        pub kanji_subject_id: i32,
    }
    impl Data {
        pub fn kanji_subject(
            &self,
        ) -> Result<&super::kanji_subject::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.kanji_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(kanji_subject),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        KanjiSubject(super::kanji_subject::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::KanjiSubject(args) => {
                    let mut selections = super::kanji_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("KanjiSubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetReading(String),
        SetReadingType(ReadingType),
        SetPrimary(bool),
        ConnectKanjiSubject(super::kanji_subject::UniqueWhereParam),
        SetKanjiSubjectId(i32),
        IncrementKanjiSubjectId(i32),
        DecrementKanjiSubjectId(i32),
        MultiplyKanjiSubjectId(i32),
        DivideKanjiSubjectId(i32),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetReading(value) => (
                    "reading".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetReadingType(value) => (
                    "reading_type".to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetPrimary(value) => (
                    "primary".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::ConnectKanjiSubject(where_param) => (
                    "KanjiSubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKanjiSubjectId(value) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Reading(::prisma_client_rust::Direction),
        ReadingType(::prisma_client_rust::Direction),
        Primary(::prisma_client_rust::Direction),
        KanjiSubjectId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Reading(direction) => (
                    "reading".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReadingType(direction) => (
                    "reading_type".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Primary(direction) => (
                    "primary".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::KanjiSubjectId(direction) => (
                    "kanjiSubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        ReadingEquals(String),
        ReadingInVec(Vec<String>),
        ReadingNotInVec(Vec<String>),
        ReadingLt(String),
        ReadingLte(String),
        ReadingGt(String),
        ReadingGte(String),
        ReadingContains(String),
        ReadingStartsWith(String),
        ReadingEndsWith(String),
        ReadingMode(QueryMode),
        ReadingNot(String),
        ReadingTypeEquals(ReadingType),
        PrimaryEquals(bool),
        KanjiSubjectIs(Vec<super::kanji_subject::WhereParam>),
        KanjiSubjectIsNot(Vec<super::kanji_subject::WhereParam>),
        KanjiSubjectIdEquals(i32),
        KanjiSubjectIdInVec(Vec<i32>),
        KanjiSubjectIdNotInVec(Vec<i32>),
        KanjiSubjectIdLt(i32),
        KanjiSubjectIdLte(i32),
        KanjiSubjectIdGt(i32),
        KanjiSubjectIdGte(i32),
        KanjiSubjectIdNot(i32),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ReadingNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingTypeEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::PrimaryEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "primary",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::KanjiSubjectIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "KanjiSubject",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "KanjiSubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::KanjiSubjectIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiSubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::KanjiSubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "kanjiSubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            reading: String,
            reading_type: ReadingType,
            primary: bool,
            kanji_subject: super::kanji_subject::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(reading::set(reading));
            _params.push(reading_type::set(reading_type));
            _params.push(primary::set(primary));
            _params.push(kanji_subject::connect(kanji_subject));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                ReadingType,
                bool,
                super::kanji_subject::UniqueWhereParam,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(reading, reading_type, primary, kanji_subject, mut _params)| {
                        _params.push(reading::set(reading));
                        _params.push(reading_type::set(reading_type));
                        _params.push(primary::set(primary));
                        _params.push(kanji_subject::connect(kanji_subject));
                        _params
                    },
                )
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (reading, reading_type, primary, kanji_subject, mut _params): (
                String,
                ReadingType,
                bool,
                super::kanji_subject::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(reading::set(reading));
            _params.push(reading_type::set(reading_type));
            _params.push(primary::set(primary));
            _params.push(kanji_subject::connect(kanji_subject));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiReading", _outputs()),
                vec![],
            )
        }
    }
}
pub mod vocabulary_reading {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod reading {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ReadingEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Reading(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ReadingLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ReadingLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ReadingGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ReadingGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ReadingContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ReadingStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ReadingEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ReadingMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ReadingNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReading(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reading(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reading(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading").build()
            }
        }
    }
    pub mod primary {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::PrimaryEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Primary(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPrimary(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Primary(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("primary").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Primary(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("primary").build()
            }
        }
    }
    pub mod accepted_answer {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::AcceptedAnswerEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AcceptedAnswer(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAcceptedAnswer(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AcceptedAnswer(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("accepted_answer").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AcceptedAnswer(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("accepted_answer").build()
            }
        }
    }
    pub mod vocabulary_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabularySubjectIs(value)
        }
        pub fn is_not(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabularySubjectIsNot(value)
        }
        pub struct Fetch(pub vocabulary_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<vocabulary_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::VocabularySubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(vocabulary_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: vocabulary_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(vocabulary_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectVocabularySubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<vocabulary_subject::SelectParam>),
            Include(Vec<vocabulary_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabularySubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("VocabularySubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vocabulary_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<vocabulary_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<vocabulary_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<vocabulary_subject::SelectParam>),
            Include(Vec<vocabulary_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabularySubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("VocabularySubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<vocabulary_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<vocabulary_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod vocabulary_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::VocabularySubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementVocabularySubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementVocabularySubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyVocabularySubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideVocabularySubjectId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetVocabularySubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabularySubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("vocabularySubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabularySubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("vocabularySubjectId").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "id",
            "reading",
            "primary",
            "accepted_answer",
            "vocabularySubjectId",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        reading: String,
        primary: bool,
        accepted_answer: bool,
        vocabulary_subject: super::vocabulary_subject::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        bool,
        bool,
        super::vocabulary_subject::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (
            reading,
            primary,
            accepted_answer,
            vocabulary_subject,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_vocabulary_reading { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: vocabulary_reading :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: vocabulary_reading :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: vocabulary_reading :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: vocabulary_reading :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: vocabulary_reading :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: vocabulary_reading :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , reading , primary , accepted_answer , vocabulary_subject , vocabulary_subject_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: vocabulary_reading :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (reading) , stringify ! (primary) , stringify ! (accepted_answer) , stringify ! (vocabulary_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: vocabulary_reading :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: vocabulary_reading :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: vocabulary_reading :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_reading :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_reading :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "reading" , "primary" , "accepted_answer" , "VocabularySubject" , "vocabularySubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: vocabulary_reading :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; reading) => { String } ; (@ field_type ; primary) => { bool } ; (@ field_type ; accepted_answer) => { bool } ; (@ field_type ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { vocabulary_subject :: Data } ; (@ field_type ; vocabulary_subject) => { crate :: prisma :: vocabulary_subject :: Data } ; (@ field_type ; vocabulary_subject_id) => { i32 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "VocabularyReading" , available fields are "id, reading, primary, accepted_answer, vocabulary_subject, vocabulary_subject_id")) } ; (@ field_module ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: vocabulary_reading :: SelectParam > :: into ($ crate :: prisma :: vocabulary_reading :: id :: Select) } ; (@ selection_field_to_selection_param ; reading) => { Into :: < $ crate :: prisma :: vocabulary_reading :: SelectParam > :: into ($ crate :: prisma :: vocabulary_reading :: reading :: Select) } ; (@ selection_field_to_selection_param ; primary) => { Into :: < $ crate :: prisma :: vocabulary_reading :: SelectParam > :: into ($ crate :: prisma :: vocabulary_reading :: primary :: Select) } ; (@ selection_field_to_selection_param ; accepted_answer) => { Into :: < $ crate :: prisma :: vocabulary_reading :: SelectParam > :: into ($ crate :: prisma :: vocabulary_reading :: accepted_answer :: Select) } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_reading :: SelectParam > :: into ($ crate :: prisma :: vocabulary_reading :: vocabulary_subject :: Select :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_reading :: SelectParam > :: into ($ crate :: prisma :: vocabulary_reading :: vocabulary_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; vocabulary_subject_id) => { Into :: < $ crate :: prisma :: vocabulary_reading :: SelectParam > :: into ($ crate :: prisma :: vocabulary_reading :: vocabulary_subject_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: vocabulary_reading :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; reading) => { "reading" } ; (@ field_serde_name ; primary) => { "primary" } ; (@ field_serde_name ; accepted_answer) => { "accepted_answer" } ; (@ field_serde_name ; vocabulary_subject) => { "VocabularySubject" } ; (@ field_serde_name ; vocabulary_subject_id) => { "vocabularySubjectId" } ; }
    pub use _select_vocabulary_reading as select;
    pub enum SelectParam {
        Id(id::Select),
        Reading(reading::Select),
        Primary(primary::Select),
        AcceptedAnswer(accepted_answer::Select),
        VocabularySubject(vocabulary_subject::Select),
        VocabularySubjectId(vocabulary_subject_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Reading(data) => data.to_selection(),
                Self::Primary(data) => data.to_selection(),
                Self::AcceptedAnswer(data) => data.to_selection(),
                Self::VocabularySubject(data) => data.to_selection(),
                Self::VocabularySubjectId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_vocabulary_reading { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: vocabulary_reading :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: vocabulary_reading :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: vocabulary_reading :: _outputs () ; selections . extend ($ crate :: prisma :: vocabulary_reading :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: vocabulary_reading :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: vocabulary_reading :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: vocabulary_reading :: _outputs () ; selections . extend ($ crate :: prisma :: vocabulary_reading :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { vocabulary_subject } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : String , pub reading : String , pub primary : bool , pub accepted_answer : bool , pub vocabulary_subject_id : i32 , $ (pub $ field : $ crate :: prisma :: vocabulary_reading :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (reading) , stringify ! (primary) , stringify ! (accepted_answer) , stringify ! (vocabulary_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , reading , primary , accepted_answer , vocabulary_subject_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; reading) , ", " , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; primary) , ", " , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; accepted_answer) , ", " , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; vocabulary_subject_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; reading) => Ok (Field :: reading) , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; primary) => Ok (Field :: primary) , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; accepted_answer) => Ok (Field :: accepted_answer) , $ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; vocabulary_subject_id) => Ok (Field :: vocabulary_subject_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut reading = None ; let mut primary = None ; let mut accepted_answer = None ; let mut vocabulary_subject_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: reading => { if reading . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; reading))) ; } reading = Some (map . next_value () ?) ; } Field :: primary => { if primary . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; primary))) ; } primary = Some (map . next_value () ?) ; } Field :: accepted_answer => { if accepted_answer . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; accepted_answer))) ; } accepted_answer = Some (map . next_value () ?) ; } Field :: vocabulary_subject_id => { if vocabulary_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; vocabulary_subject_id))) ; } vocabulary_subject_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; id))) ? ; let reading = reading . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; reading))) ? ; let primary = primary . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; primary))) ? ; let accepted_answer = accepted_answer . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; accepted_answer))) ? ; let vocabulary_subject_id = vocabulary_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_reading :: include ! (@ field_serde_name ; vocabulary_subject_id))) ? ; Ok (Data { id , reading , primary , accepted_answer , vocabulary_subject_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "reading" , "primary" , "accepted_answer" , "VocabularySubject" , "vocabularySubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: vocabulary_reading :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { vocabulary_subject :: Data } ; (@ field_type ; vocabulary_subject) => { crate :: prisma :: vocabulary_subject :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "VocabularyReading" , available relations are "vocabulary_subject")) } ; (@ field_module ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_reading :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_reading :: vocabulary_subject :: Include :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_reading :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_reading :: vocabulary_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: vocabulary_reading :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; reading) => { "reading" } ; (@ field_serde_name ; primary) => { "primary" } ; (@ field_serde_name ; accepted_answer) => { "accepted_answer" } ; (@ field_serde_name ; vocabulary_subject) => { "VocabularySubject" } ; (@ field_serde_name ; vocabulary_subject_id) => { "vocabularySubjectId" } ; }
    pub use _include_vocabulary_reading as include;
    pub enum IncludeParam {
        Id(id::Include),
        Reading(reading::Include),
        Primary(primary::Include),
        AcceptedAnswer(accepted_answer::Include),
        VocabularySubject(vocabulary_subject::Include),
        VocabularySubjectId(vocabulary_subject_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Reading(data) => data.to_selection(),
                Self::Primary(data) => data.to_selection(),
                Self::AcceptedAnswer(data) => data.to_selection(),
                Self::VocabularySubject(data) => data.to_selection(),
                Self::VocabularySubjectId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "reading")]
        pub reading: String,
        #[serde(rename = "primary")]
        pub primary: bool,
        #[serde(rename = "accepted_answer")]
        pub accepted_answer: bool,
        #[serde(rename = "VocabularySubject")]
        pub vocabulary_subject: Option<Box<super::vocabulary_subject::Data>>,
        #[serde(rename = "vocabularySubjectId")]
        pub vocabulary_subject_id: i32,
    }
    impl Data {
        pub fn vocabulary_subject(
            &self,
        ) -> Result<&super::vocabulary_subject::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.vocabulary_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(vocabulary_subject),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        VocabularySubject(super::vocabulary_subject::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::VocabularySubject(args) => {
                    let mut selections = super::vocabulary_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("VocabularySubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetReading(String),
        SetPrimary(bool),
        SetAcceptedAnswer(bool),
        ConnectVocabularySubject(super::vocabulary_subject::UniqueWhereParam),
        SetVocabularySubjectId(i32),
        IncrementVocabularySubjectId(i32),
        DecrementVocabularySubjectId(i32),
        MultiplyVocabularySubjectId(i32),
        DivideVocabularySubjectId(i32),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetReading(value) => (
                    "reading".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPrimary(value) => (
                    "primary".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetAcceptedAnswer(value) => (
                    "accepted_answer".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::ConnectVocabularySubject(where_param) => (
                    "VocabularySubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::vocabulary_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Reading(::prisma_client_rust::Direction),
        Primary(::prisma_client_rust::Direction),
        AcceptedAnswer(::prisma_client_rust::Direction),
        VocabularySubjectId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Reading(direction) => (
                    "reading".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Primary(direction) => (
                    "primary".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AcceptedAnswer(direction) => (
                    "accepted_answer".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::VocabularySubjectId(direction) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        ReadingEquals(String),
        ReadingInVec(Vec<String>),
        ReadingNotInVec(Vec<String>),
        ReadingLt(String),
        ReadingLte(String),
        ReadingGt(String),
        ReadingGte(String),
        ReadingContains(String),
        ReadingStartsWith(String),
        ReadingEndsWith(String),
        ReadingMode(QueryMode),
        ReadingNot(String),
        PrimaryEquals(bool),
        AcceptedAnswerEquals(bool),
        VocabularySubjectIs(Vec<super::vocabulary_subject::WhereParam>),
        VocabularySubjectIsNot(Vec<super::vocabulary_subject::WhereParam>),
        VocabularySubjectIdEquals(i32),
        VocabularySubjectIdInVec(Vec<i32>),
        VocabularySubjectIdNotInVec(Vec<i32>),
        VocabularySubjectIdLt(i32),
        VocabularySubjectIdLte(i32),
        VocabularySubjectIdGt(i32),
        VocabularySubjectIdGte(i32),
        VocabularySubjectIdNot(i32),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ReadingNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::PrimaryEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "primary",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::AcceptedAnswerEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "accepted_answer",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::VocabularySubjectIs(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "VocabularySubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "is".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "VocabularySubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdEquals(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )]),
                    )
                }
                Self::VocabularySubjectIdInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdNotInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            reading: String,
            primary: bool,
            accepted_answer: bool,
            vocabulary_subject: super::vocabulary_subject::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(reading::set(reading));
            _params.push(primary::set(primary));
            _params.push(accepted_answer::set(accepted_answer));
            _params.push(vocabulary_subject::connect(vocabulary_subject));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                bool,
                bool,
                super::vocabulary_subject::UniqueWhereParam,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(reading, primary, accepted_answer, vocabulary_subject, mut _params)| {
                        _params.push(reading::set(reading));
                        _params.push(primary::set(primary));
                        _params.push(accepted_answer::set(accepted_answer));
                        _params.push(vocabulary_subject::connect(vocabulary_subject));
                        _params
                    },
                )
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (reading, primary, accepted_answer, vocabulary_subject, mut _params): (
                String,
                bool,
                bool,
                super::vocabulary_subject::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(reading::set(reading));
            _params.push(primary::set(primary));
            _params.push(accepted_answer::set(accepted_answer));
            _params.push(vocabulary_subject::connect(vocabulary_subject));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularyReading", _outputs()),
                vec![],
            )
        }
    }
}
pub mod subject_index {
    use super::_prisma::*;
    use super::*;
    pub mod subject_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: SubjectType) -> T {
            Set(value).into()
        }
        pub fn equals(value: SubjectType) -> WhereParam {
            WhereParam::SubjectTypeEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SubjectType(direction)
        }
        pub struct Set(pub SubjectType);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSubjectType(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SubjectType(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("subject_type").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SubjectType(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("subject_type").build()
            }
        }
    }
    pub mod subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::SubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::SubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::SubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::SubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::SubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::SubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::SubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::SubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSubjectId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("subjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("subjectId").build()
            }
        }
    }
    pub mod radical_ref {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<radical_subject::WhereParam>) -> WhereParam {
            WhereParam::RadicalRefSome(value)
        }
        pub fn every(value: Vec<radical_subject::WhereParam>) -> WhereParam {
            WhereParam::RadicalRefEvery(value)
        }
        pub fn none(value: Vec<radical_subject::WhereParam>) -> WhereParam {
            WhereParam::RadicalRefNone(value)
        }
        pub struct Fetch(pub radical_subject::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<radical_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: radical_subject::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: radical_subject::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::RadicalRef(fetch.0)
            }
        }
        pub fn fetch(params: Vec<radical_subject::WhereParam>) -> Fetch {
            Fetch(radical_subject::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<radical_subject::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<radical_subject::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectRadicalRef(params)
        }
        pub fn set(params: Vec<radical_subject::UniqueWhereParam>) -> SetParam {
            SetParam::SetRadicalRef(params)
        }
        pub struct Connect(pub Vec<radical_subject::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectRadicalRef(value.0)
            }
        }
        pub enum Include {
            Select(radical_subject::ManyArgs, Vec<radical_subject::SelectParam>),
            Include(
                radical_subject::ManyArgs,
                Vec<radical_subject::IncludeParam>,
            ),
            Fetch(radical_subject::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RadicalRef(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("radical_ref");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = radical_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(radical_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: radical_subject::ManyArgs,
                nested_selections: Vec<radical_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: radical_subject::ManyArgs,
                nested_selections: Vec<radical_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(radical_subject::ManyArgs, Vec<radical_subject::SelectParam>),
            Include(
                radical_subject::ManyArgs,
                Vec<radical_subject::IncludeParam>,
            ),
            Fetch(radical_subject::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RadicalRef(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("radical_ref");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(radical_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: radical_subject::ManyArgs,
                nested_selections: Vec<radical_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: radical_subject::ManyArgs,
                nested_selections: Vec<radical_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod kanji_ref_amal {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefAmalSome(value)
        }
        pub fn every(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefAmalEvery(value)
        }
        pub fn none(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefAmalNone(value)
        }
        pub struct Fetch(pub kanji_subject::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<kanji_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: kanji_subject::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: kanji_subject::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::KanjiRefAmal(fetch.0)
            }
        }
        pub fn fetch(params: Vec<kanji_subject::WhereParam>) -> Fetch {
            Fetch(kanji_subject::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<kanji_subject::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<kanji_subject::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectKanjiRefAmal(params)
        }
        pub fn set(params: Vec<kanji_subject::UniqueWhereParam>) -> SetParam {
            SetParam::SetKanjiRefAmal(params)
        }
        pub struct Connect(pub Vec<kanji_subject::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectKanjiRefAmal(value.0)
            }
        }
        pub enum Include {
            Select(kanji_subject::ManyArgs, Vec<kanji_subject::SelectParam>),
            Include(kanji_subject::ManyArgs, Vec<kanji_subject::IncludeParam>),
            Fetch(kanji_subject::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiRefAmal(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("kanji_ref_amal");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = kanji_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(kanji_subject::ManyArgs, Vec<kanji_subject::SelectParam>),
            Include(kanji_subject::ManyArgs, Vec<kanji_subject::IncludeParam>),
            Fetch(kanji_subject::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiRefAmal(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("kanji_ref_amal");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod kanji_ref_sim {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefSimSome(value)
        }
        pub fn every(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefSimEvery(value)
        }
        pub fn none(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefSimNone(value)
        }
        pub struct Fetch(pub kanji_subject::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<kanji_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: kanji_subject::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: kanji_subject::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::KanjiRefSim(fetch.0)
            }
        }
        pub fn fetch(params: Vec<kanji_subject::WhereParam>) -> Fetch {
            Fetch(kanji_subject::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<kanji_subject::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<kanji_subject::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectKanjiRefSim(params)
        }
        pub fn set(params: Vec<kanji_subject::UniqueWhereParam>) -> SetParam {
            SetParam::SetKanjiRefSim(params)
        }
        pub struct Connect(pub Vec<kanji_subject::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectKanjiRefSim(value.0)
            }
        }
        pub enum Include {
            Select(kanji_subject::ManyArgs, Vec<kanji_subject::SelectParam>),
            Include(kanji_subject::ManyArgs, Vec<kanji_subject::IncludeParam>),
            Fetch(kanji_subject::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiRefSim(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("kanji_ref_sim");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = kanji_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(kanji_subject::ManyArgs, Vec<kanji_subject::SelectParam>),
            Include(kanji_subject::ManyArgs, Vec<kanji_subject::IncludeParam>),
            Fetch(kanji_subject::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiRefSim(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("kanji_ref_sim");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod kanji_ref_comp {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefCompSome(value)
        }
        pub fn every(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefCompEvery(value)
        }
        pub fn none(value: Vec<kanji_subject::WhereParam>) -> WhereParam {
            WhereParam::KanjiRefCompNone(value)
        }
        pub struct Fetch(pub kanji_subject::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<kanji_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: kanji_subject::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: kanji_subject::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::KanjiRefComp(fetch.0)
            }
        }
        pub fn fetch(params: Vec<kanji_subject::WhereParam>) -> Fetch {
            Fetch(kanji_subject::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<kanji_subject::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<kanji_subject::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectKanjiRefComp(params)
        }
        pub fn set(params: Vec<kanji_subject::UniqueWhereParam>) -> SetParam {
            SetParam::SetKanjiRefComp(params)
        }
        pub struct Connect(pub Vec<kanji_subject::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectKanjiRefComp(value.0)
            }
        }
        pub enum Include {
            Select(kanji_subject::ManyArgs, Vec<kanji_subject::SelectParam>),
            Include(kanji_subject::ManyArgs, Vec<kanji_subject::IncludeParam>),
            Fetch(kanji_subject::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KanjiRefComp(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("kanji_ref_comp");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = kanji_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(kanji_subject::ManyArgs, Vec<kanji_subject::SelectParam>),
            Include(kanji_subject::ManyArgs, Vec<kanji_subject::IncludeParam>),
            Fetch(kanji_subject::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KanjiRefComp(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("kanji_ref_comp");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(kanji_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: kanji_subject::ManyArgs,
                nested_selections: Vec<kanji_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod vocab_ref {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabRefSome(value)
        }
        pub fn every(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabRefEvery(value)
        }
        pub fn none(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabRefNone(value)
        }
        pub struct Fetch(pub vocabulary_subject::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<vocabulary_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: vocabulary_subject::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: vocabulary_subject::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::VocabRef(fetch.0)
            }
        }
        pub fn fetch(params: Vec<vocabulary_subject::WhereParam>) -> Fetch {
            Fetch(vocabulary_subject::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<vocabulary_subject::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<vocabulary_subject::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectVocabRef(params)
        }
        pub fn set(params: Vec<vocabulary_subject::UniqueWhereParam>) -> SetParam {
            SetParam::SetVocabRef(params)
        }
        pub struct Connect(pub Vec<vocabulary_subject::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectVocabRef(value.0)
            }
        }
        pub enum Include {
            Select(
                vocabulary_subject::ManyArgs,
                Vec<vocabulary_subject::SelectParam>,
            ),
            Include(
                vocabulary_subject::ManyArgs,
                Vec<vocabulary_subject::IncludeParam>,
            ),
            Fetch(vocabulary_subject::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabRef(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("vocab_ref");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = vocabulary_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: vocabulary_subject::ManyArgs,
                nested_selections: Vec<vocabulary_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: vocabulary_subject::ManyArgs,
                nested_selections: Vec<vocabulary_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                vocabulary_subject::ManyArgs,
                Vec<vocabulary_subject::SelectParam>,
            ),
            Include(
                vocabulary_subject::ManyArgs,
                Vec<vocabulary_subject::IncludeParam>,
            ),
            Fetch(vocabulary_subject::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabRef(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("vocab_ref");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: vocabulary_subject::ManyArgs,
                nested_selections: Vec<vocabulary_subject::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: vocabulary_subject::ManyArgs,
                nested_selections: Vec<vocabulary_subject::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod subject_progress {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_progress::WhereParam>) -> WhereParam {
            WhereParam::SubjectProgressSome(value)
        }
        pub fn every(value: Vec<subject_progress::WhereParam>) -> WhereParam {
            WhereParam::SubjectProgressEvery(value)
        }
        pub fn none(value: Vec<subject_progress::WhereParam>) -> WhereParam {
            WhereParam::SubjectProgressNone(value)
        }
        pub struct Fetch(pub subject_progress::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_progress::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_progress::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_progress::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::SubjectProgress(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_progress::WhereParam>) -> Fetch {
            Fetch(subject_progress::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_progress::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_progress::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectSubjectProgress(params)
        }
        pub fn set(params: Vec<subject_progress::UniqueWhereParam>) -> SetParam {
            SetParam::SetSubjectProgress(params)
        }
        pub struct Connect(pub Vec<subject_progress::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectSubjectProgress(value.0)
            }
        }
        pub enum Include {
            Select(
                subject_progress::ManyArgs,
                Vec<subject_progress::SelectParam>,
            ),
            Include(
                subject_progress::ManyArgs,
                Vec<subject_progress::IncludeParam>,
            ),
            Fetch(subject_progress::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SubjectProgress(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("SubjectProgress");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_progress::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_progress::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_progress::ManyArgs,
                nested_selections: Vec<subject_progress::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_progress::ManyArgs,
                nested_selections: Vec<subject_progress::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                subject_progress::ManyArgs,
                Vec<subject_progress::SelectParam>,
            ),
            Include(
                subject_progress::ManyArgs,
                Vec<subject_progress::IncludeParam>,
            ),
            Fetch(subject_progress::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SubjectProgress(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("SubjectProgress");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_progress::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_progress::ManyArgs,
                nested_selections: Vec<subject_progress::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_progress::ManyArgs,
                nested_selections: Vec<subject_progress::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["subject_type", "subjectId"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        subject_type: SubjectType,
        subject_id: i32,
        _params: Vec<SetParam>,
    ) -> (SubjectType, i32, Vec<SetParam>) {
        (subject_type, subject_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_subject_index { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: subject_index :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: subject_index :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: subject_index :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: subject_index :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: subject_index :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: subject_index :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { subject_type , subject_id , radical_ref , kanji_ref_amal , kanji_ref_sim , kanji_ref_comp , vocab_ref , subject_progress } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: subject_index :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (subject_type) , stringify ! (subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: subject_index :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: subject_index :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: subject_index :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_index :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_index :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["subject_type" , "subjectId" , "radical_ref" , "kanji_ref_amal" , "kanji_ref_sim" , "kanji_ref_comp" , "vocab_ref" , "SubjectProgress"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: subject_index :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; subject_type) => { SubjectType } ; (@ field_type ; subject_id) => { i32 } ; (@ field_type ; radical_ref : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < radical_ref :: Data > } ; (@ field_type ; radical_ref) => { Vec < crate :: prisma :: radical_subject :: Data > } ; (@ field_type ; kanji_ref_amal : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < kanji_ref_amal :: Data > } ; (@ field_type ; kanji_ref_amal) => { Vec < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; kanji_ref_sim : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < kanji_ref_sim :: Data > } ; (@ field_type ; kanji_ref_sim) => { Vec < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; kanji_ref_comp : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < kanji_ref_comp :: Data > } ; (@ field_type ; kanji_ref_comp) => { Vec < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; vocab_ref : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < vocab_ref :: Data > } ; (@ field_type ; vocab_ref) => { Vec < crate :: prisma :: vocabulary_subject :: Data > } ; (@ field_type ; subject_progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < subject_progress :: Data > } ; (@ field_type ; subject_progress) => { Vec < crate :: prisma :: subject_progress :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "SubjectIndex" , available fields are "subject_type, subject_id, radical_ref, kanji_ref_amal, kanji_ref_sim, kanji_ref_comp, vocab_ref, subject_progress")) } ; (@ field_module ; radical_ref : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: radical_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_ref_amal : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_ref_sim : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_ref_comp : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; vocab_ref : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; subject_progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_progress :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; subject_type) => { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: subject_type :: Select) } ; (@ selection_field_to_selection_param ; subject_id) => { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: subject_id :: Select) } ; (@ selection_field_to_selection_param ; radical_ref $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: radical_ref :: Select :: $ selection_mode ($ crate :: prisma :: radical_subject :: ManyArgs :: new ($ crate :: prisma :: radical_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: radical_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; radical_ref $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: radical_ref :: Select :: Fetch ($ crate :: prisma :: radical_subject :: ManyArgs :: new ($ crate :: prisma :: radical_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; kanji_ref_amal $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_amal :: Select :: $ selection_mode ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: kanji_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_ref_amal $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_amal :: Select :: Fetch ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; kanji_ref_sim $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_sim :: Select :: $ selection_mode ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: kanji_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_ref_sim $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_sim :: Select :: Fetch ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; kanji_ref_comp $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_comp :: Select :: $ selection_mode ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: kanji_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_ref_comp $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_comp :: Select :: Fetch ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; vocab_ref $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: vocab_ref :: Select :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: ManyArgs :: new ($ crate :: prisma :: vocabulary_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: vocabulary_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocab_ref $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: vocab_ref :: Select :: Fetch ($ crate :: prisma :: vocabulary_subject :: ManyArgs :: new ($ crate :: prisma :: vocabulary_subject :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; subject_progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: subject_progress :: Select :: $ selection_mode ($ crate :: prisma :: subject_progress :: ManyArgs :: new ($ crate :: prisma :: subject_progress :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_progress :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; subject_progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: SelectParam > :: into ($ crate :: prisma :: subject_index :: subject_progress :: Select :: Fetch ($ crate :: prisma :: subject_progress :: ManyArgs :: new ($ crate :: prisma :: subject_progress :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: subject_index :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; subject_type) => { "subject_type" } ; (@ field_serde_name ; subject_id) => { "subjectId" } ; (@ field_serde_name ; radical_ref) => { "radical_ref" } ; (@ field_serde_name ; kanji_ref_amal) => { "kanji_ref_amal" } ; (@ field_serde_name ; kanji_ref_sim) => { "kanji_ref_sim" } ; (@ field_serde_name ; kanji_ref_comp) => { "kanji_ref_comp" } ; (@ field_serde_name ; vocab_ref) => { "vocab_ref" } ; (@ field_serde_name ; subject_progress) => { "SubjectProgress" } ; }
    pub use _select_subject_index as select;
    pub enum SelectParam {
        SubjectType(subject_type::Select),
        SubjectId(subject_id::Select),
        RadicalRef(radical_ref::Select),
        KanjiRefAmal(kanji_ref_amal::Select),
        KanjiRefSim(kanji_ref_sim::Select),
        KanjiRefComp(kanji_ref_comp::Select),
        VocabRef(vocab_ref::Select),
        SubjectProgress(subject_progress::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::SubjectType(data) => data.to_selection(),
                Self::SubjectId(data) => data.to_selection(),
                Self::RadicalRef(data) => data.to_selection(),
                Self::KanjiRefAmal(data) => data.to_selection(),
                Self::KanjiRefSim(data) => data.to_selection(),
                Self::KanjiRefComp(data) => data.to_selection(),
                Self::VocabRef(data) => data.to_selection(),
                Self::SubjectProgress(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_subject_index { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: subject_index :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: subject_index :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: subject_index :: _outputs () ; selections . extend ($ crate :: prisma :: subject_index :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: subject_index :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: subject_index :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: subject_index :: _outputs () ; selections . extend ($ crate :: prisma :: subject_index :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { radical_ref , kanji_ref_amal , kanji_ref_sim , kanji_ref_comp , vocab_ref , subject_progress } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub subject_type : SubjectType , pub subject_id : i32 , $ (pub $ field : $ crate :: prisma :: subject_index :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (subject_type) , stringify ! (subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , subject_type , subject_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; subject_type) , ", " , $ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; subject_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; subject_type) => Ok (Field :: subject_type) , $ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; subject_id) => Ok (Field :: subject_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut subject_type = None ; let mut subject_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: subject_type => { if subject_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; subject_type))) ; } subject_type = Some (map . next_value () ?) ; } Field :: subject_id => { if subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; subject_id))) ; } subject_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; $ field))) ? ;) * let subject_type = subject_type . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; subject_type))) ? ; let subject_id = subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: subject_index :: include ! (@ field_serde_name ; subject_id))) ? ; Ok (Data { subject_type , subject_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["subject_type" , "subjectId" , "radical_ref" , "kanji_ref_amal" , "kanji_ref_sim" , "kanji_ref_comp" , "vocab_ref" , "SubjectProgress"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: subject_index :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; radical_ref : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < radical_ref :: Data > } ; (@ field_type ; radical_ref) => { Vec < crate :: prisma :: radical_subject :: Data > } ; (@ field_type ; kanji_ref_amal : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < kanji_ref_amal :: Data > } ; (@ field_type ; kanji_ref_amal) => { Vec < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; kanji_ref_sim : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < kanji_ref_sim :: Data > } ; (@ field_type ; kanji_ref_sim) => { Vec < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; kanji_ref_comp : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < kanji_ref_comp :: Data > } ; (@ field_type ; kanji_ref_comp) => { Vec < crate :: prisma :: kanji_subject :: Data > } ; (@ field_type ; vocab_ref : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < vocab_ref :: Data > } ; (@ field_type ; vocab_ref) => { Vec < crate :: prisma :: vocabulary_subject :: Data > } ; (@ field_type ; subject_progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < subject_progress :: Data > } ; (@ field_type ; subject_progress) => { Vec < crate :: prisma :: subject_progress :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SubjectIndex" , available relations are "radical_ref, kanji_ref_amal, kanji_ref_sim, kanji_ref_comp, vocab_ref, subject_progress")) } ; (@ field_module ; radical_ref : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: radical_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_ref_amal : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_ref_sim : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; kanji_ref_comp : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; vocab_ref : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; subject_progress : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_progress :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; radical_ref $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: radical_ref :: Include :: $ selection_mode ($ crate :: prisma :: radical_subject :: ManyArgs :: new ($ crate :: prisma :: radical_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: radical_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; radical_ref $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: radical_ref :: Include :: Fetch ($ crate :: prisma :: radical_subject :: ManyArgs :: new ($ crate :: prisma :: radical_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; kanji_ref_amal $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_amal :: Include :: $ selection_mode ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: kanji_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_ref_amal $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_amal :: Include :: Fetch ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; kanji_ref_sim $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_sim :: Include :: $ selection_mode ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: kanji_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_ref_sim $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_sim :: Include :: Fetch ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; kanji_ref_comp $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_comp :: Include :: $ selection_mode ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: kanji_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; kanji_ref_comp $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: kanji_ref_comp :: Include :: Fetch ($ crate :: prisma :: kanji_subject :: ManyArgs :: new ($ crate :: prisma :: kanji_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; vocab_ref $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: vocab_ref :: Include :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: ManyArgs :: new ($ crate :: prisma :: vocabulary_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: vocabulary_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocab_ref $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: vocab_ref :: Include :: Fetch ($ crate :: prisma :: vocabulary_subject :: ManyArgs :: new ($ crate :: prisma :: vocabulary_subject :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; subject_progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: subject_progress :: Include :: $ selection_mode ($ crate :: prisma :: subject_progress :: ManyArgs :: new ($ crate :: prisma :: subject_progress :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_progress :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; subject_progress $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: subject_index :: IncludeParam > :: into ($ crate :: prisma :: subject_index :: subject_progress :: Include :: Fetch ($ crate :: prisma :: subject_progress :: ManyArgs :: new ($ crate :: prisma :: subject_progress :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: subject_index :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; subject_type) => { "subject_type" } ; (@ field_serde_name ; subject_id) => { "subjectId" } ; (@ field_serde_name ; radical_ref) => { "radical_ref" } ; (@ field_serde_name ; kanji_ref_amal) => { "kanji_ref_amal" } ; (@ field_serde_name ; kanji_ref_sim) => { "kanji_ref_sim" } ; (@ field_serde_name ; kanji_ref_comp) => { "kanji_ref_comp" } ; (@ field_serde_name ; vocab_ref) => { "vocab_ref" } ; (@ field_serde_name ; subject_progress) => { "SubjectProgress" } ; }
    pub use _include_subject_index as include;
    pub enum IncludeParam {
        SubjectType(subject_type::Include),
        SubjectId(subject_id::Include),
        RadicalRef(radical_ref::Include),
        KanjiRefAmal(kanji_ref_amal::Include),
        KanjiRefSim(kanji_ref_sim::Include),
        KanjiRefComp(kanji_ref_comp::Include),
        VocabRef(vocab_ref::Include),
        SubjectProgress(subject_progress::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::SubjectType(data) => data.to_selection(),
                Self::SubjectId(data) => data.to_selection(),
                Self::RadicalRef(data) => data.to_selection(),
                Self::KanjiRefAmal(data) => data.to_selection(),
                Self::KanjiRefSim(data) => data.to_selection(),
                Self::KanjiRefComp(data) => data.to_selection(),
                Self::VocabRef(data) => data.to_selection(),
                Self::SubjectProgress(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "subject_type")]
        pub subject_type: SubjectType,
        #[serde(rename = "subjectId")]
        pub subject_id: i32,
        #[serde(rename = "radical_ref")]
        pub radical_ref: Option<Vec<super::radical_subject::Data>>,
        #[serde(rename = "kanji_ref_amal")]
        pub kanji_ref_amal: Option<Vec<super::kanji_subject::Data>>,
        #[serde(rename = "kanji_ref_sim")]
        pub kanji_ref_sim: Option<Vec<super::kanji_subject::Data>>,
        #[serde(rename = "kanji_ref_comp")]
        pub kanji_ref_comp: Option<Vec<super::kanji_subject::Data>>,
        #[serde(rename = "vocab_ref")]
        pub vocab_ref: Option<Vec<super::vocabulary_subject::Data>>,
        #[serde(rename = "SubjectProgress")]
        pub subject_progress: Option<Vec<super::subject_progress::Data>>,
    }
    impl Data {
        pub fn radical_ref(
            &self,
        ) -> Result<&Vec<super::radical_subject::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.radical_ref
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(radical_ref),
                ))
        }
        pub fn kanji_ref_amal(
            &self,
        ) -> Result<&Vec<super::kanji_subject::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.kanji_ref_amal
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(kanji_ref_amal),
                ))
        }
        pub fn kanji_ref_sim(
            &self,
        ) -> Result<&Vec<super::kanji_subject::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.kanji_ref_sim
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(kanji_ref_sim),
                ))
        }
        pub fn kanji_ref_comp(
            &self,
        ) -> Result<&Vec<super::kanji_subject::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.kanji_ref_comp
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(kanji_ref_comp),
                ))
        }
        pub fn vocab_ref(
            &self,
        ) -> Result<
            &Vec<super::vocabulary_subject::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.vocab_ref
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(vocab_ref),
                ))
        }
        pub fn subject_progress(
            &self,
        ) -> Result<
            &Vec<super::subject_progress::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.subject_progress.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(subject_progress)),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        RadicalRef(super::radical_subject::ManyArgs),
        KanjiRefAmal(super::kanji_subject::ManyArgs),
        KanjiRefSim(super::kanji_subject::ManyArgs),
        KanjiRefComp(super::kanji_subject::ManyArgs),
        VocabRef(super::vocabulary_subject::ManyArgs),
        SubjectProgress(super::subject_progress::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::RadicalRef(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::radical_subject::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("radical_ref");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::KanjiRefAmal(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::kanji_subject::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("kanji_ref_amal");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::KanjiRefSim(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::kanji_subject::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("kanji_ref_sim");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::KanjiRefComp(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::kanji_subject::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("kanji_ref_comp");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::VocabRef(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::vocabulary_subject::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("vocab_ref");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::SubjectProgress(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_progress::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("SubjectProgress");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetSubjectType(SubjectType),
        SetSubjectId(i32),
        IncrementSubjectId(i32),
        DecrementSubjectId(i32),
        MultiplySubjectId(i32),
        DivideSubjectId(i32),
        ConnectRadicalRef(Vec<super::radical_subject::UniqueWhereParam>),
        DisconnectRadicalRef(Vec<super::radical_subject::UniqueWhereParam>),
        SetRadicalRef(Vec<super::radical_subject::UniqueWhereParam>),
        ConnectKanjiRefAmal(Vec<super::kanji_subject::UniqueWhereParam>),
        DisconnectKanjiRefAmal(Vec<super::kanji_subject::UniqueWhereParam>),
        SetKanjiRefAmal(Vec<super::kanji_subject::UniqueWhereParam>),
        ConnectKanjiRefSim(Vec<super::kanji_subject::UniqueWhereParam>),
        DisconnectKanjiRefSim(Vec<super::kanji_subject::UniqueWhereParam>),
        SetKanjiRefSim(Vec<super::kanji_subject::UniqueWhereParam>),
        ConnectKanjiRefComp(Vec<super::kanji_subject::UniqueWhereParam>),
        DisconnectKanjiRefComp(Vec<super::kanji_subject::UniqueWhereParam>),
        SetKanjiRefComp(Vec<super::kanji_subject::UniqueWhereParam>),
        ConnectVocabRef(Vec<super::vocabulary_subject::UniqueWhereParam>),
        DisconnectVocabRef(Vec<super::vocabulary_subject::UniqueWhereParam>),
        SetVocabRef(Vec<super::vocabulary_subject::UniqueWhereParam>),
        ConnectSubjectProgress(Vec<super::subject_progress::UniqueWhereParam>),
        DisconnectSubjectProgress(Vec<super::subject_progress::UniqueWhereParam>),
        SetSubjectProgress(Vec<super::subject_progress::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetSubjectType(value) => (
                    "subject_type".to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetSubjectId(value) => (
                    "subjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSubjectId(value) => (
                    "subjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSubjectId(value) => (
                    "subjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySubjectId(value) => (
                    "subjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSubjectId(value) => (
                    "subjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectRadicalRef(where_params) => (
                    "radical_ref".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::radical_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectRadicalRef(where_params) => (
                    "radical_ref".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::radical_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetRadicalRef(where_params) => (
                    "radical_ref".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::radical_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectKanjiRefAmal(where_params) => (
                    "kanji_ref_amal".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectKanjiRefAmal(where_params) => (
                    "kanji_ref_amal".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetKanjiRefAmal(where_params) => (
                    "kanji_ref_amal".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectKanjiRefSim(where_params) => (
                    "kanji_ref_sim".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectKanjiRefSim(where_params) => (
                    "kanji_ref_sim".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetKanjiRefSim(where_params) => (
                    "kanji_ref_sim".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectKanjiRefComp(where_params) => (
                    "kanji_ref_comp".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectKanjiRefComp(where_params) => (
                    "kanji_ref_comp".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetKanjiRefComp(where_params) => (
                    "kanji_ref_comp".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectVocabRef(where_params) => (
                    "vocab_ref".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::vocabulary_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectVocabRef(where_params) => (
                    "vocab_ref".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::vocabulary_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetVocabRef(where_params) => (
                    "vocab_ref".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::vocabulary_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectSubjectProgress(where_params) => (
                    "SubjectProgress".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_progress::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectSubjectProgress(where_params) => (
                    "SubjectProgress".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_progress::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetSubjectProgress(where_params) => (
                    "SubjectProgress".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_progress::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        SubjectType(::prisma_client_rust::Direction),
        SubjectId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::SubjectType(direction) => (
                    "subject_type".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SubjectId(direction) => (
                    "subjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SubjectTypeEquals(SubjectType),
        SubjectIdEquals(i32),
        SubjectIdInVec(Vec<i32>),
        SubjectIdNotInVec(Vec<i32>),
        SubjectIdLt(i32),
        SubjectIdLte(i32),
        SubjectIdGt(i32),
        SubjectIdGte(i32),
        SubjectIdNot(i32),
        RadicalRefSome(Vec<super::radical_subject::WhereParam>),
        RadicalRefEvery(Vec<super::radical_subject::WhereParam>),
        RadicalRefNone(Vec<super::radical_subject::WhereParam>),
        KanjiRefAmalSome(Vec<super::kanji_subject::WhereParam>),
        KanjiRefAmalEvery(Vec<super::kanji_subject::WhereParam>),
        KanjiRefAmalNone(Vec<super::kanji_subject::WhereParam>),
        KanjiRefSimSome(Vec<super::kanji_subject::WhereParam>),
        KanjiRefSimEvery(Vec<super::kanji_subject::WhereParam>),
        KanjiRefSimNone(Vec<super::kanji_subject::WhereParam>),
        KanjiRefCompSome(Vec<super::kanji_subject::WhereParam>),
        KanjiRefCompEvery(Vec<super::kanji_subject::WhereParam>),
        KanjiRefCompNone(Vec<super::kanji_subject::WhereParam>),
        VocabRefSome(Vec<super::vocabulary_subject::WhereParam>),
        VocabRefEvery(Vec<super::vocabulary_subject::WhereParam>),
        VocabRefNone(Vec<super::vocabulary_subject::WhereParam>),
        SubjectProgressSome(Vec<super::subject_progress::WhereParam>),
        SubjectProgressEvery(Vec<super::subject_progress::WhereParam>),
        SubjectProgressNone(Vec<super::subject_progress::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::SubjectTypeEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subject_type",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::SubjectIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SubjectIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::SubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "subjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::RadicalRefSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "radical_ref",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RadicalRefEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "radical_ref",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RadicalRefNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "radical_ref",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiRefAmalSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "kanji_ref_amal",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiRefAmalEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "kanji_ref_amal",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::KanjiRefAmalNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "kanji_ref_amal",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiRefSimSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "kanji_ref_sim",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiRefSimEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "kanji_ref_sim",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiRefSimNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "kanji_ref_sim",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiRefCompSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "kanji_ref_comp",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KanjiRefCompEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "kanji_ref_comp",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::KanjiRefCompNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "kanji_ref_comp",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VocabRefSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "vocab_ref",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VocabRefEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "vocab_ref",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VocabRefNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "vocab_ref",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SubjectProgressSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "SubjectProgress",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::SubjectProgressEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "SubjectProgress",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::SubjectProgressNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "SubjectProgress",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        SubjectIdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SubjectIdEquals(value) => Self::SubjectIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            subject_type: SubjectType,
            subject_id: i32,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(subject_type::set(subject_type));
            _params.push(subject_id::set(subject_id));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(SubjectType, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(subject_type, subject_id, mut _params)| {
                    _params.push(subject_type::set(subject_type));
                    _params.push(subject_id::set(subject_id));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (subject_type, subject_id, mut _params): (SubjectType, i32, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(subject_type::set(subject_type));
            _params.push(subject_id::set(subject_id));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("SubjectIndex", _outputs()),
                vec![],
            )
        }
    }
}
pub mod radical_subject {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod amalgamation_subjects {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::AmalgamationSubjectsSome(value)
        }
        pub fn every(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::AmalgamationSubjectsEvery(value)
        }
        pub fn none(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::AmalgamationSubjectsNone(value)
        }
        pub struct Fetch(pub subject_index::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_index::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_index::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_index::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::AmalgamationSubjects(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_index::WhereParam>) -> Fetch {
            Fetch(subject_index::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_index::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAmalgamationSubjects(params)
        }
        pub fn set(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::SetAmalgamationSubjects(params)
        }
        pub struct Connect(pub Vec<subject_index::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAmalgamationSubjects(value.0)
            }
        }
        pub enum Include {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AmalgamationSubjects(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection =
                    ::prisma_client_rust::Selection::builder("amalgamation_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_index::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AmalgamationSubjects(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection =
                    ::prisma_client_rust::Selection::builder("amalgamation_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod auxiliary_meanings {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsSome(value)
        }
        pub fn every(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsEvery(value)
        }
        pub fn none(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsNone(value)
        }
        pub struct Fetch(pub auxiliary_meaning::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<auxiliary_meaning::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: auxiliary_meaning::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: auxiliary_meaning::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::AuxiliaryMeanings(fetch.0)
            }
        }
        pub fn fetch(params: Vec<auxiliary_meaning::WhereParam>) -> Fetch {
            Fetch(auxiliary_meaning::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAuxiliaryMeanings(params)
        }
        pub fn set(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::SetAuxiliaryMeanings(params)
        }
        pub struct Connect(pub Vec<auxiliary_meaning::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAuxiliaryMeanings(value.0)
            }
        }
        pub enum Include {
            Select(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::SelectParam>,
            ),
            Include(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::IncludeParam>,
            ),
            Fetch(auxiliary_meaning::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AuxiliaryMeanings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = auxiliary_meaning::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(auxiliary_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::SelectParam>,
            ),
            Include(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::IncludeParam>,
            ),
            Fetch(auxiliary_meaning::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AuxiliaryMeanings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(auxiliary_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod characters {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::CharactersEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Characters(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CharactersInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CharactersNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CharactersLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CharactersLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CharactersGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CharactersGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CharactersContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CharactersStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CharactersEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::CharactersMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CharactersNot(value)
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCharacters(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Characters(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("characters").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Characters(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("characters").build()
            }
        }
    }
    pub mod lesson_position {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::LessonPositionEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LessonPosition(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LessonPositionInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LessonPositionNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::LessonPositionLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::LessonPositionLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::LessonPositionGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::LessonPositionGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::LessonPositionNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementLessonPosition(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementLessonPosition(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyLessonPosition(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideLessonPosition(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLessonPosition(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LessonPosition(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("lesson_position").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LessonPosition(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("lesson_position").build()
            }
        }
    }
    pub mod level {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::LevelEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Level(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LevelInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LevelNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::LevelLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::LevelLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::LevelGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::LevelGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::LevelNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementLevel(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementLevel(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyLevel(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideLevel(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLevel(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Level(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("level").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Level(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("level").build()
            }
        }
    }
    pub mod meaning_mnemonic {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MeaningMnemonic(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningMnemonicInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningMnemonicNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::MeaningMnemonicMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMeaningMnemonic(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MeaningMnemonic(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning_mnemonic").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MeaningMnemonic(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning_mnemonic").build()
            }
        }
    }
    pub mod meanings {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsSome(value)
        }
        pub fn every(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsEvery(value)
        }
        pub fn none(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsNone(value)
        }
        pub struct Fetch(pub subject_meaning::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_meaning::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_meaning::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_meaning::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Meanings(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_meaning::WhereParam>) -> Fetch {
            Fetch(subject_meaning::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_meaning::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMeanings(params)
        }
        pub fn set(params: Vec<subject_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::SetMeanings(params)
        }
        pub struct Connect(pub Vec<subject_meaning::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectMeanings(value.0)
            }
        }
        pub enum Include {
            Select(subject_meaning::ManyArgs, Vec<subject_meaning::SelectParam>),
            Include(
                subject_meaning::ManyArgs,
                Vec<subject_meaning::IncludeParam>,
            ),
            Fetch(subject_meaning::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Meanings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_meaning::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(subject_meaning::ManyArgs, Vec<subject_meaning::SelectParam>),
            Include(
                subject_meaning::ManyArgs,
                Vec<subject_meaning::IncludeParam>,
            ),
            Fetch(subject_meaning::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Meanings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "id",
            "characters",
            "lesson_position",
            "level",
            "meaning_mnemonic",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        id: i32,
        lesson_position: i32,
        level: i32,
        meaning_mnemonic: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, i32, String, Vec<SetParam>) {
        (id, lesson_position, level, meaning_mnemonic, _params)
    }
    #[macro_export]
    macro_rules ! _select_radical_subject { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: radical_subject :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: radical_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: radical_subject :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: radical_subject :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: radical_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: radical_subject :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , amalgamation_subjects , auxiliary_meanings , characters , lesson_position , level , meaning_mnemonic , meanings } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: radical_subject :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (characters) , stringify ! (lesson_position) , stringify ! (level) , stringify ! (meaning_mnemonic)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: radical_subject :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: radical_subject :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: radical_subject :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: radical_subject :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: radical_subject :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "amalgamation_subjects" , "auxiliary_meanings" , "characters" , "lesson_position" , "level" , "meaning_mnemonic" , "meanings"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: radical_subject :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; amalgamation_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < amalgamation_subjects :: Data > } ; (@ field_type ; amalgamation_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < auxiliary_meanings :: Data > } ; (@ field_type ; auxiliary_meanings) => { Vec < crate :: prisma :: auxiliary_meaning :: Data > } ; (@ field_type ; characters) => { Option < String > } ; (@ field_type ; lesson_position) => { i32 } ; (@ field_type ; level) => { i32 } ; (@ field_type ; meaning_mnemonic) => { String } ; (@ field_type ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < meanings :: Data > } ; (@ field_type ; meanings) => { Vec < crate :: prisma :: subject_meaning :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "RadicalSubject" , available fields are "id, amalgamation_subjects, auxiliary_meanings, characters, lesson_position, level, meaning_mnemonic, meanings")) } ; (@ field_module ; amalgamation_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: auxiliary_meaning :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_meaning :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: id :: Select) } ; (@ selection_field_to_selection_param ; amalgamation_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: amalgamation_subjects :: Select :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; amalgamation_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: amalgamation_subjects :: Select :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: auxiliary_meanings :: Select :: $ selection_mode ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: auxiliary_meaning :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: auxiliary_meanings :: Select :: Fetch ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; characters) => { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: characters :: Select) } ; (@ selection_field_to_selection_param ; lesson_position) => { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: lesson_position :: Select) } ; (@ selection_field_to_selection_param ; level) => { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: level :: Select) } ; (@ selection_field_to_selection_param ; meaning_mnemonic) => { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: meaning_mnemonic :: Select) } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: meanings :: Select :: $ selection_mode ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_meaning :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: radical_subject :: SelectParam > :: into ($ crate :: prisma :: radical_subject :: meanings :: Select :: Fetch ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: radical_subject :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; amalgamation_subjects) => { "amalgamation_subjects" } ; (@ field_serde_name ; auxiliary_meanings) => { "auxiliary_meanings" } ; (@ field_serde_name ; characters) => { "characters" } ; (@ field_serde_name ; lesson_position) => { "lesson_position" } ; (@ field_serde_name ; level) => { "level" } ; (@ field_serde_name ; meaning_mnemonic) => { "meaning_mnemonic" } ; (@ field_serde_name ; meanings) => { "meanings" } ; }
    pub use _select_radical_subject as select;
    pub enum SelectParam {
        Id(id::Select),
        AmalgamationSubjects(amalgamation_subjects::Select),
        AuxiliaryMeanings(auxiliary_meanings::Select),
        Characters(characters::Select),
        LessonPosition(lesson_position::Select),
        Level(level::Select),
        MeaningMnemonic(meaning_mnemonic::Select),
        Meanings(meanings::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AmalgamationSubjects(data) => data.to_selection(),
                Self::AuxiliaryMeanings(data) => data.to_selection(),
                Self::Characters(data) => data.to_selection(),
                Self::LessonPosition(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::MeaningMnemonic(data) => data.to_selection(),
                Self::Meanings(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_radical_subject { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: radical_subject :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: radical_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: radical_subject :: _outputs () ; selections . extend ($ crate :: prisma :: radical_subject :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: radical_subject :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: radical_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: radical_subject :: _outputs () ; selections . extend ($ crate :: prisma :: radical_subject :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { amalgamation_subjects , auxiliary_meanings , meanings } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : i32 , pub characters : Option < String > , pub lesson_position : i32 , pub level : i32 , pub meaning_mnemonic : String , $ (pub $ field : $ crate :: prisma :: radical_subject :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (characters) , stringify ! (lesson_position) , stringify ! (level) , stringify ! (meaning_mnemonic)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , characters , lesson_position , level , meaning_mnemonic } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; characters) , ", " , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; lesson_position) , ", " , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; level) , ", " , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; meaning_mnemonic) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; characters) => Ok (Field :: characters) , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; lesson_position) => Ok (Field :: lesson_position) , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; level) => Ok (Field :: level) , $ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; meaning_mnemonic) => Ok (Field :: meaning_mnemonic) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut characters = None ; let mut lesson_position = None ; let mut level = None ; let mut meaning_mnemonic = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: characters => { if characters . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; characters))) ; } characters = Some (map . next_value () ?) ; } Field :: lesson_position => { if lesson_position . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; lesson_position))) ; } lesson_position = Some (map . next_value () ?) ; } Field :: level => { if level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; level))) ; } level = Some (map . next_value () ?) ; } Field :: meaning_mnemonic => { if meaning_mnemonic . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; meaning_mnemonic))) ; } meaning_mnemonic = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; id))) ? ; let characters = characters . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; characters))) ? ; let lesson_position = lesson_position . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; lesson_position))) ? ; let level = level . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; level))) ? ; let meaning_mnemonic = meaning_mnemonic . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: radical_subject :: include ! (@ field_serde_name ; meaning_mnemonic))) ? ; Ok (Data { id , characters , lesson_position , level , meaning_mnemonic , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "amalgamation_subjects" , "auxiliary_meanings" , "characters" , "lesson_position" , "level" , "meaning_mnemonic" , "meanings"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: radical_subject :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; amalgamation_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < amalgamation_subjects :: Data > } ; (@ field_type ; amalgamation_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < auxiliary_meanings :: Data > } ; (@ field_type ; auxiliary_meanings) => { Vec < crate :: prisma :: auxiliary_meaning :: Data > } ; (@ field_type ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < meanings :: Data > } ; (@ field_type ; meanings) => { Vec < crate :: prisma :: subject_meaning :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "RadicalSubject" , available relations are "amalgamation_subjects, auxiliary_meanings, meanings")) } ; (@ field_module ; amalgamation_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: auxiliary_meaning :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_meaning :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; amalgamation_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: radical_subject :: IncludeParam > :: into ($ crate :: prisma :: radical_subject :: amalgamation_subjects :: Include :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; amalgamation_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: radical_subject :: IncludeParam > :: into ($ crate :: prisma :: radical_subject :: amalgamation_subjects :: Include :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: radical_subject :: IncludeParam > :: into ($ crate :: prisma :: radical_subject :: auxiliary_meanings :: Include :: $ selection_mode ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: auxiliary_meaning :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: radical_subject :: IncludeParam > :: into ($ crate :: prisma :: radical_subject :: auxiliary_meanings :: Include :: Fetch ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: radical_subject :: IncludeParam > :: into ($ crate :: prisma :: radical_subject :: meanings :: Include :: $ selection_mode ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_meaning :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: radical_subject :: IncludeParam > :: into ($ crate :: prisma :: radical_subject :: meanings :: Include :: Fetch ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: radical_subject :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; amalgamation_subjects) => { "amalgamation_subjects" } ; (@ field_serde_name ; auxiliary_meanings) => { "auxiliary_meanings" } ; (@ field_serde_name ; characters) => { "characters" } ; (@ field_serde_name ; lesson_position) => { "lesson_position" } ; (@ field_serde_name ; level) => { "level" } ; (@ field_serde_name ; meaning_mnemonic) => { "meaning_mnemonic" } ; (@ field_serde_name ; meanings) => { "meanings" } ; }
    pub use _include_radical_subject as include;
    pub enum IncludeParam {
        Id(id::Include),
        AmalgamationSubjects(amalgamation_subjects::Include),
        AuxiliaryMeanings(auxiliary_meanings::Include),
        Characters(characters::Include),
        LessonPosition(lesson_position::Include),
        Level(level::Include),
        MeaningMnemonic(meaning_mnemonic::Include),
        Meanings(meanings::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AmalgamationSubjects(data) => data.to_selection(),
                Self::AuxiliaryMeanings(data) => data.to_selection(),
                Self::Characters(data) => data.to_selection(),
                Self::LessonPosition(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::MeaningMnemonic(data) => data.to_selection(),
                Self::Meanings(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "amalgamation_subjects")]
        pub amalgamation_subjects: Option<Vec<super::subject_index::Data>>,
        #[serde(rename = "auxiliary_meanings")]
        pub auxiliary_meanings: Option<Vec<super::auxiliary_meaning::Data>>,
        #[serde(rename = "characters")]
        pub characters: Option<String>,
        #[serde(rename = "lesson_position")]
        pub lesson_position: i32,
        #[serde(rename = "level")]
        pub level: i32,
        #[serde(rename = "meaning_mnemonic")]
        pub meaning_mnemonic: String,
        #[serde(rename = "meanings")]
        pub meanings: Option<Vec<super::subject_meaning::Data>>,
    }
    impl Data {
        pub fn amalgamation_subjects(
            &self,
        ) -> Result<&Vec<super::subject_index::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.amalgamation_subjects.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    amalgamation_subjects
                )),
            )
        }
        pub fn auxiliary_meanings(
            &self,
        ) -> Result<
            &Vec<super::auxiliary_meaning::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.auxiliary_meanings.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(auxiliary_meanings)),
            )
        }
        pub fn meanings(
            &self,
        ) -> Result<&Vec<super::subject_meaning::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.meanings
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(meanings),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        AmalgamationSubjects(super::subject_index::ManyArgs),
        AuxiliaryMeanings(super::auxiliary_meaning::ManyArgs),
        Meanings(super::subject_meaning::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::AmalgamationSubjects(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_index::_outputs());
                    let mut builder =
                        ::prisma_client_rust::Selection::builder("amalgamation_subjects");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::AuxiliaryMeanings(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::auxiliary_meaning::_outputs());
                    let mut builder =
                        ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Meanings(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_meaning::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("meanings");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        ConnectAmalgamationSubjects(Vec<super::subject_index::UniqueWhereParam>),
        DisconnectAmalgamationSubjects(Vec<super::subject_index::UniqueWhereParam>),
        SetAmalgamationSubjects(Vec<super::subject_index::UniqueWhereParam>),
        ConnectAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        DisconnectAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        SetAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        SetCharacters(Option<String>),
        SetLessonPosition(i32),
        IncrementLessonPosition(i32),
        DecrementLessonPosition(i32),
        MultiplyLessonPosition(i32),
        DivideLessonPosition(i32),
        SetLevel(i32),
        IncrementLevel(i32),
        DecrementLevel(i32),
        MultiplyLevel(i32),
        DivideLevel(i32),
        SetMeaningMnemonic(String),
        ConnectMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
        DisconnectMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
        SetMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectAmalgamationSubjects(where_params) => (
                    "amalgamation_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAmalgamationSubjects(where_params) => (
                    "amalgamation_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAmalgamationSubjects(where_params) => (
                    "amalgamation_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetCharacters(value) => (
                    "characters".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMeaningMnemonic(value) => (
                    "meaning_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Characters(::prisma_client_rust::Direction),
        LessonPosition(::prisma_client_rust::Direction),
        Level(::prisma_client_rust::Direction),
        MeaningMnemonic(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Characters(direction) => (
                    "characters".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LessonPosition(direction) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Level(direction) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MeaningMnemonic(direction) => (
                    "meaning_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        AmalgamationSubjectsSome(Vec<super::subject_index::WhereParam>),
        AmalgamationSubjectsEvery(Vec<super::subject_index::WhereParam>),
        AmalgamationSubjectsNone(Vec<super::subject_index::WhereParam>),
        AuxiliaryMeaningsSome(Vec<super::auxiliary_meaning::WhereParam>),
        AuxiliaryMeaningsEvery(Vec<super::auxiliary_meaning::WhereParam>),
        AuxiliaryMeaningsNone(Vec<super::auxiliary_meaning::WhereParam>),
        CharactersEquals(Option<String>),
        CharactersInVec(Vec<String>),
        CharactersNotInVec(Vec<String>),
        CharactersLt(String),
        CharactersLte(String),
        CharactersGt(String),
        CharactersGte(String),
        CharactersContains(String),
        CharactersStartsWith(String),
        CharactersEndsWith(String),
        CharactersMode(QueryMode),
        CharactersNot(String),
        LessonPositionEquals(i32),
        LessonPositionInVec(Vec<i32>),
        LessonPositionNotInVec(Vec<i32>),
        LessonPositionLt(i32),
        LessonPositionLte(i32),
        LessonPositionGt(i32),
        LessonPositionGte(i32),
        LessonPositionNot(i32),
        LevelEquals(i32),
        LevelInVec(Vec<i32>),
        LevelNotInVec(Vec<i32>),
        LevelLt(i32),
        LevelLte(i32),
        LevelGt(i32),
        LevelGte(i32),
        LevelNot(i32),
        MeaningMnemonicEquals(String),
        MeaningMnemonicInVec(Vec<String>),
        MeaningMnemonicNotInVec(Vec<String>),
        MeaningMnemonicLt(String),
        MeaningMnemonicLte(String),
        MeaningMnemonicGt(String),
        MeaningMnemonicGte(String),
        MeaningMnemonicContains(String),
        MeaningMnemonicStartsWith(String),
        MeaningMnemonicEndsWith(String),
        MeaningMnemonicMode(QueryMode),
        MeaningMnemonicNot(String),
        MeaningsSome(Vec<super::subject_meaning::WhereParam>),
        MeaningsEvery(Vec<super::subject_meaning::WhereParam>),
        MeaningsNone(Vec<super::subject_meaning::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::AmalgamationSubjectsSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "amalgamation_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AmalgamationSubjectsEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "amalgamation_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AmalgamationSubjectsNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "amalgamation_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AuxiliaryMeaningsSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AuxiliaryMeaningsEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AuxiliaryMeaningsNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::CharactersEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::CharactersInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CharactersNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CharactersLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::CharactersNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::LessonPositionEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LessonPositionNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LessonPositionLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LevelNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LevelLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::MeaningMnemonicEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningMnemonicNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningMnemonicLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicStartsWith(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "meaning_mnemonic",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )]),
                    )
                }
                Self::MeaningMnemonicEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::MeaningMnemonicNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningsSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningsEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningsNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: i32,
            lesson_position: i32,
            level: i32,
            meaning_mnemonic: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(lesson_position::set(lesson_position));
            _params.push(level::set(level));
            _params.push(meaning_mnemonic::set(meaning_mnemonic));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(i32, i32, i32, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(id, lesson_position, level, meaning_mnemonic, mut _params)| {
                        _params.push(id::set(id));
                        _params.push(lesson_position::set(lesson_position));
                        _params.push(level::set(level));
                        _params.push(meaning_mnemonic::set(meaning_mnemonic));
                        _params
                    },
                )
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, lesson_position, level, meaning_mnemonic, mut _params): (
                i32,
                i32,
                i32,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(lesson_position::set(lesson_position));
            _params.push(level::set(level));
            _params.push(meaning_mnemonic::set(meaning_mnemonic));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("RadicalSubject", _outputs()),
                vec![],
            )
        }
    }
}
pub mod kanji_subject {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod amalgamation_subjects {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::AmalgamationSubjectsSome(value)
        }
        pub fn every(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::AmalgamationSubjectsEvery(value)
        }
        pub fn none(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::AmalgamationSubjectsNone(value)
        }
        pub struct Fetch(pub subject_index::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_index::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_index::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_index::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::AmalgamationSubjects(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_index::WhereParam>) -> Fetch {
            Fetch(subject_index::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_index::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAmalgamationSubjects(params)
        }
        pub fn set(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::SetAmalgamationSubjects(params)
        }
        pub struct Connect(pub Vec<subject_index::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAmalgamationSubjects(value.0)
            }
        }
        pub enum Include {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AmalgamationSubjects(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection =
                    ::prisma_client_rust::Selection::builder("amalgamation_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_index::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AmalgamationSubjects(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection =
                    ::prisma_client_rust::Selection::builder("amalgamation_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod auxiliary_meanings {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsSome(value)
        }
        pub fn every(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsEvery(value)
        }
        pub fn none(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsNone(value)
        }
        pub struct Fetch(pub auxiliary_meaning::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<auxiliary_meaning::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: auxiliary_meaning::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: auxiliary_meaning::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::AuxiliaryMeanings(fetch.0)
            }
        }
        pub fn fetch(params: Vec<auxiliary_meaning::WhereParam>) -> Fetch {
            Fetch(auxiliary_meaning::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAuxiliaryMeanings(params)
        }
        pub fn set(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::SetAuxiliaryMeanings(params)
        }
        pub struct Connect(pub Vec<auxiliary_meaning::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAuxiliaryMeanings(value.0)
            }
        }
        pub enum Include {
            Select(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::SelectParam>,
            ),
            Include(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::IncludeParam>,
            ),
            Fetch(auxiliary_meaning::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AuxiliaryMeanings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = auxiliary_meaning::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(auxiliary_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::SelectParam>,
            ),
            Include(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::IncludeParam>,
            ),
            Fetch(auxiliary_meaning::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AuxiliaryMeanings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(auxiliary_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod characters {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::CharactersEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Characters(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CharactersInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CharactersNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CharactersLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CharactersLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CharactersGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CharactersGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CharactersContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CharactersStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CharactersEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::CharactersMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CharactersNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCharacters(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Characters(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("characters").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Characters(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("characters").build()
            }
        }
    }
    pub mod component_subjects {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::ComponentSubjectsSome(value)
        }
        pub fn every(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::ComponentSubjectsEvery(value)
        }
        pub fn none(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::ComponentSubjectsNone(value)
        }
        pub struct Fetch(pub subject_index::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_index::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_index::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_index::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::ComponentSubjects(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_index::WhereParam>) -> Fetch {
            Fetch(subject_index::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_index::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectComponentSubjects(params)
        }
        pub fn set(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::SetComponentSubjects(params)
        }
        pub struct Connect(pub Vec<subject_index::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectComponentSubjects(value.0)
            }
        }
        pub enum Include {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentSubjects(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("component_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_index::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentSubjects(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("component_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod lesson_position {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::LessonPositionEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LessonPosition(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LessonPositionInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LessonPositionNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::LessonPositionLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::LessonPositionLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::LessonPositionGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::LessonPositionGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::LessonPositionNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementLessonPosition(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementLessonPosition(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyLessonPosition(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideLessonPosition(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLessonPosition(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LessonPosition(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("lesson_position").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LessonPosition(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("lesson_position").build()
            }
        }
    }
    pub mod level {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::LevelEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Level(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LevelInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LevelNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::LevelLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::LevelLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::LevelGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::LevelGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::LevelNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementLevel(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementLevel(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyLevel(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideLevel(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLevel(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Level(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("level").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Level(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("level").build()
            }
        }
    }
    pub mod meaning_hint {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MeaningHintEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MeaningHint(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningHintInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningHintNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MeaningHintLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MeaningHintLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MeaningHintGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MeaningHintGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MeaningHintContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MeaningHintStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MeaningHintEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::MeaningHintMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MeaningHintNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMeaningHint(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MeaningHint(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning_hint").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MeaningHint(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning_hint").build()
            }
        }
    }
    pub mod meaning_mnemonic {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MeaningMnemonic(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningMnemonicInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningMnemonicNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::MeaningMnemonicMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMeaningMnemonic(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MeaningMnemonic(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning_mnemonic").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MeaningMnemonic(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning_mnemonic").build()
            }
        }
    }
    pub mod meanings {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsSome(value)
        }
        pub fn every(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsEvery(value)
        }
        pub fn none(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsNone(value)
        }
        pub struct Fetch(pub subject_meaning::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_meaning::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_meaning::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_meaning::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Meanings(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_meaning::WhereParam>) -> Fetch {
            Fetch(subject_meaning::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_meaning::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMeanings(params)
        }
        pub fn set(params: Vec<subject_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::SetMeanings(params)
        }
        pub struct Connect(pub Vec<subject_meaning::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectMeanings(value.0)
            }
        }
        pub enum Include {
            Select(subject_meaning::ManyArgs, Vec<subject_meaning::SelectParam>),
            Include(
                subject_meaning::ManyArgs,
                Vec<subject_meaning::IncludeParam>,
            ),
            Fetch(subject_meaning::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Meanings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_meaning::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(subject_meaning::ManyArgs, Vec<subject_meaning::SelectParam>),
            Include(
                subject_meaning::ManyArgs,
                Vec<subject_meaning::IncludeParam>,
            ),
            Fetch(subject_meaning::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Meanings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod reading_hint {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ReadingHintEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReadingHint(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingHintInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingHintNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ReadingHintLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ReadingHintLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ReadingHintGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ReadingHintGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ReadingHintContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ReadingHintStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ReadingHintEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ReadingHintMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ReadingHintNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReadingHint(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReadingHint(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading_hint").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReadingHint(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading_hint").build()
            }
        }
    }
    pub mod reading_mnemonic {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReadingMnemonic(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingMnemonicInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingMnemonicNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ReadingMnemonicMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReadingMnemonic(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReadingMnemonic(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading_mnemonic").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReadingMnemonic(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading_mnemonic").build()
            }
        }
    }
    pub mod readings {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<kanji_reading::WhereParam>) -> WhereParam {
            WhereParam::ReadingsSome(value)
        }
        pub fn every(value: Vec<kanji_reading::WhereParam>) -> WhereParam {
            WhereParam::ReadingsEvery(value)
        }
        pub fn none(value: Vec<kanji_reading::WhereParam>) -> WhereParam {
            WhereParam::ReadingsNone(value)
        }
        pub struct Fetch(pub kanji_reading::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<kanji_reading::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: kanji_reading::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: kanji_reading::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Readings(fetch.0)
            }
        }
        pub fn fetch(params: Vec<kanji_reading::WhereParam>) -> Fetch {
            Fetch(kanji_reading::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<kanji_reading::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<kanji_reading::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectReadings(params)
        }
        pub fn set(params: Vec<kanji_reading::UniqueWhereParam>) -> SetParam {
            SetParam::SetReadings(params)
        }
        pub struct Connect(pub Vec<kanji_reading::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectReadings(value.0)
            }
        }
        pub enum Include {
            Select(kanji_reading::ManyArgs, Vec<kanji_reading::SelectParam>),
            Include(kanji_reading::ManyArgs, Vec<kanji_reading::IncludeParam>),
            Fetch(kanji_reading::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Readings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("readings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = kanji_reading::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(kanji_reading::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: kanji_reading::ManyArgs,
                nested_selections: Vec<kanji_reading::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: kanji_reading::ManyArgs,
                nested_selections: Vec<kanji_reading::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(kanji_reading::ManyArgs, Vec<kanji_reading::SelectParam>),
            Include(kanji_reading::ManyArgs, Vec<kanji_reading::IncludeParam>),
            Fetch(kanji_reading::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Readings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("readings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(kanji_reading::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: kanji_reading::ManyArgs,
                nested_selections: Vec<kanji_reading::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: kanji_reading::ManyArgs,
                nested_selections: Vec<kanji_reading::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod visually_similar_subjects {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::VisuallySimilarSubjectsSome(value)
        }
        pub fn every(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::VisuallySimilarSubjectsEvery(value)
        }
        pub fn none(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::VisuallySimilarSubjectsNone(value)
        }
        pub struct Fetch(pub subject_index::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_index::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_index::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_index::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::VisuallySimilarSubjects(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_index::WhereParam>) -> Fetch {
            Fetch(subject_index::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_index::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectVisuallySimilarSubjects(params)
        }
        pub fn set(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::SetVisuallySimilarSubjects(params)
        }
        pub struct Connect(pub Vec<subject_index::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectVisuallySimilarSubjects(value.0)
            }
        }
        pub enum Include {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VisuallySimilarSubjects(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection =
                    ::prisma_client_rust::Selection::builder("visually_similar_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_index::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VisuallySimilarSubjects(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection =
                    ::prisma_client_rust::Selection::builder("visually_similar_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "id",
            "characters",
            "lesson_position",
            "level",
            "meaning_hint",
            "meaning_mnemonic",
            "reading_hint",
            "reading_mnemonic",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        id: i32,
        characters: String,
        lesson_position: i32,
        level: i32,
        meaning_hint: String,
        meaning_mnemonic: String,
        reading_hint: String,
        reading_mnemonic: String,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        String,
        i32,
        i32,
        String,
        String,
        String,
        String,
        Vec<SetParam>,
    ) {
        (
            id,
            characters,
            lesson_position,
            level,
            meaning_hint,
            meaning_mnemonic,
            reading_hint,
            reading_mnemonic,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_kanji_subject { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: kanji_subject :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: kanji_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: kanji_subject :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: kanji_subject :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: kanji_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: kanji_subject :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , amalgamation_subjects , auxiliary_meanings , characters , component_subjects , lesson_position , level , meaning_hint , meaning_mnemonic , meanings , reading_hint , reading_mnemonic , readings , visually_similar_subjects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: kanji_subject :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (characters) , stringify ! (lesson_position) , stringify ! (level) , stringify ! (meaning_hint) , stringify ! (meaning_mnemonic) , stringify ! (reading_hint) , stringify ! (reading_mnemonic)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: kanji_subject :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: kanji_subject :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: kanji_subject :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "amalgamation_subjects" , "auxiliary_meanings" , "characters" , "component_subjects" , "lesson_position" , "level" , "meaning_hint" , "meaning_mnemonic" , "meanings" , "reading_hint" , "reading_mnemonic" , "readings" , "visually_similar_subjects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: kanji_subject :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; amalgamation_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < amalgamation_subjects :: Data > } ; (@ field_type ; amalgamation_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < auxiliary_meanings :: Data > } ; (@ field_type ; auxiliary_meanings) => { Vec < crate :: prisma :: auxiliary_meaning :: Data > } ; (@ field_type ; characters) => { String } ; (@ field_type ; component_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_subjects :: Data > } ; (@ field_type ; component_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; lesson_position) => { i32 } ; (@ field_type ; level) => { i32 } ; (@ field_type ; meaning_hint) => { String } ; (@ field_type ; meaning_mnemonic) => { String } ; (@ field_type ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < meanings :: Data > } ; (@ field_type ; meanings) => { Vec < crate :: prisma :: subject_meaning :: Data > } ; (@ field_type ; reading_hint) => { String } ; (@ field_type ; reading_mnemonic) => { String } ; (@ field_type ; readings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < readings :: Data > } ; (@ field_type ; readings) => { Vec < crate :: prisma :: kanji_reading :: Data > } ; (@ field_type ; visually_similar_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < visually_similar_subjects :: Data > } ; (@ field_type ; visually_similar_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "KanjiSubject" , available fields are "id, amalgamation_subjects, auxiliary_meanings, characters, component_subjects, lesson_position, level, meaning_hint, meaning_mnemonic, meanings, reading_hint, reading_mnemonic, readings, visually_similar_subjects")) } ; (@ field_module ; amalgamation_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: auxiliary_meaning :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; component_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_meaning :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; readings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_reading :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; visually_similar_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: id :: Select) } ; (@ selection_field_to_selection_param ; amalgamation_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: amalgamation_subjects :: Select :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; amalgamation_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: amalgamation_subjects :: Select :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: auxiliary_meanings :: Select :: $ selection_mode ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: auxiliary_meaning :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: auxiliary_meanings :: Select :: Fetch ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; characters) => { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: characters :: Select) } ; (@ selection_field_to_selection_param ; component_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: component_subjects :: Select :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: component_subjects :: Select :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; lesson_position) => { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: lesson_position :: Select) } ; (@ selection_field_to_selection_param ; level) => { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: level :: Select) } ; (@ selection_field_to_selection_param ; meaning_hint) => { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: meaning_hint :: Select) } ; (@ selection_field_to_selection_param ; meaning_mnemonic) => { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: meaning_mnemonic :: Select) } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: meanings :: Select :: $ selection_mode ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_meaning :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: meanings :: Select :: Fetch ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; reading_hint) => { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: reading_hint :: Select) } ; (@ selection_field_to_selection_param ; reading_mnemonic) => { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: reading_mnemonic :: Select) } ; (@ selection_field_to_selection_param ; readings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: readings :: Select :: $ selection_mode ($ crate :: prisma :: kanji_reading :: ManyArgs :: new ($ crate :: prisma :: kanji_reading :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: kanji_reading :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; readings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: readings :: Select :: Fetch ($ crate :: prisma :: kanji_reading :: ManyArgs :: new ($ crate :: prisma :: kanji_reading :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; visually_similar_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: visually_similar_subjects :: Select :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; visually_similar_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: SelectParam > :: into ($ crate :: prisma :: kanji_subject :: visually_similar_subjects :: Select :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: kanji_subject :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; amalgamation_subjects) => { "amalgamation_subjects" } ; (@ field_serde_name ; auxiliary_meanings) => { "auxiliary_meanings" } ; (@ field_serde_name ; characters) => { "characters" } ; (@ field_serde_name ; component_subjects) => { "component_subjects" } ; (@ field_serde_name ; lesson_position) => { "lesson_position" } ; (@ field_serde_name ; level) => { "level" } ; (@ field_serde_name ; meaning_hint) => { "meaning_hint" } ; (@ field_serde_name ; meaning_mnemonic) => { "meaning_mnemonic" } ; (@ field_serde_name ; meanings) => { "meanings" } ; (@ field_serde_name ; reading_hint) => { "reading_hint" } ; (@ field_serde_name ; reading_mnemonic) => { "reading_mnemonic" } ; (@ field_serde_name ; readings) => { "readings" } ; (@ field_serde_name ; visually_similar_subjects) => { "visually_similar_subjects" } ; }
    pub use _select_kanji_subject as select;
    pub enum SelectParam {
        Id(id::Select),
        AmalgamationSubjects(amalgamation_subjects::Select),
        AuxiliaryMeanings(auxiliary_meanings::Select),
        Characters(characters::Select),
        ComponentSubjects(component_subjects::Select),
        LessonPosition(lesson_position::Select),
        Level(level::Select),
        MeaningHint(meaning_hint::Select),
        MeaningMnemonic(meaning_mnemonic::Select),
        Meanings(meanings::Select),
        ReadingHint(reading_hint::Select),
        ReadingMnemonic(reading_mnemonic::Select),
        Readings(readings::Select),
        VisuallySimilarSubjects(visually_similar_subjects::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AmalgamationSubjects(data) => data.to_selection(),
                Self::AuxiliaryMeanings(data) => data.to_selection(),
                Self::Characters(data) => data.to_selection(),
                Self::ComponentSubjects(data) => data.to_selection(),
                Self::LessonPosition(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::MeaningHint(data) => data.to_selection(),
                Self::MeaningMnemonic(data) => data.to_selection(),
                Self::Meanings(data) => data.to_selection(),
                Self::ReadingHint(data) => data.to_selection(),
                Self::ReadingMnemonic(data) => data.to_selection(),
                Self::Readings(data) => data.to_selection(),
                Self::VisuallySimilarSubjects(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_kanji_subject { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: kanji_subject :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: kanji_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: kanji_subject :: _outputs () ; selections . extend ($ crate :: prisma :: kanji_subject :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: kanji_subject :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: kanji_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: kanji_subject :: _outputs () ; selections . extend ($ crate :: prisma :: kanji_subject :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { amalgamation_subjects , auxiliary_meanings , component_subjects , meanings , readings , visually_similar_subjects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : i32 , pub characters : String , pub lesson_position : i32 , pub level : i32 , pub meaning_hint : String , pub meaning_mnemonic : String , pub reading_hint : String , pub reading_mnemonic : String , $ (pub $ field : $ crate :: prisma :: kanji_subject :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (characters) , stringify ! (lesson_position) , stringify ! (level) , stringify ! (meaning_hint) , stringify ! (meaning_mnemonic) , stringify ! (reading_hint) , stringify ! (reading_mnemonic)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , characters , lesson_position , level , meaning_hint , meaning_mnemonic , reading_hint , reading_mnemonic } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; characters) , ", " , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; lesson_position) , ", " , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; level) , ", " , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; meaning_hint) , ", " , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; meaning_mnemonic) , ", " , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; reading_hint) , ", " , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; reading_mnemonic) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; characters) => Ok (Field :: characters) , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; lesson_position) => Ok (Field :: lesson_position) , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; level) => Ok (Field :: level) , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; meaning_hint) => Ok (Field :: meaning_hint) , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; meaning_mnemonic) => Ok (Field :: meaning_mnemonic) , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; reading_hint) => Ok (Field :: reading_hint) , $ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; reading_mnemonic) => Ok (Field :: reading_mnemonic) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut characters = None ; let mut lesson_position = None ; let mut level = None ; let mut meaning_hint = None ; let mut meaning_mnemonic = None ; let mut reading_hint = None ; let mut reading_mnemonic = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: characters => { if characters . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; characters))) ; } characters = Some (map . next_value () ?) ; } Field :: lesson_position => { if lesson_position . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; lesson_position))) ; } lesson_position = Some (map . next_value () ?) ; } Field :: level => { if level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; level))) ; } level = Some (map . next_value () ?) ; } Field :: meaning_hint => { if meaning_hint . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; meaning_hint))) ; } meaning_hint = Some (map . next_value () ?) ; } Field :: meaning_mnemonic => { if meaning_mnemonic . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; meaning_mnemonic))) ; } meaning_mnemonic = Some (map . next_value () ?) ; } Field :: reading_hint => { if reading_hint . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; reading_hint))) ; } reading_hint = Some (map . next_value () ?) ; } Field :: reading_mnemonic => { if reading_mnemonic . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; reading_mnemonic))) ; } reading_mnemonic = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; id))) ? ; let characters = characters . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; characters))) ? ; let lesson_position = lesson_position . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; lesson_position))) ? ; let level = level . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; level))) ? ; let meaning_hint = meaning_hint . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; meaning_hint))) ? ; let meaning_mnemonic = meaning_mnemonic . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; meaning_mnemonic))) ? ; let reading_hint = reading_hint . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; reading_hint))) ? ; let reading_mnemonic = reading_mnemonic . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: kanji_subject :: include ! (@ field_serde_name ; reading_mnemonic))) ? ; Ok (Data { id , characters , lesson_position , level , meaning_hint , meaning_mnemonic , reading_hint , reading_mnemonic , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "amalgamation_subjects" , "auxiliary_meanings" , "characters" , "component_subjects" , "lesson_position" , "level" , "meaning_hint" , "meaning_mnemonic" , "meanings" , "reading_hint" , "reading_mnemonic" , "readings" , "visually_similar_subjects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: kanji_subject :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; amalgamation_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < amalgamation_subjects :: Data > } ; (@ field_type ; amalgamation_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < auxiliary_meanings :: Data > } ; (@ field_type ; auxiliary_meanings) => { Vec < crate :: prisma :: auxiliary_meaning :: Data > } ; (@ field_type ; component_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_subjects :: Data > } ; (@ field_type ; component_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < meanings :: Data > } ; (@ field_type ; meanings) => { Vec < crate :: prisma :: subject_meaning :: Data > } ; (@ field_type ; readings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < readings :: Data > } ; (@ field_type ; readings) => { Vec < crate :: prisma :: kanji_reading :: Data > } ; (@ field_type ; visually_similar_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < visually_similar_subjects :: Data > } ; (@ field_type ; visually_similar_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "KanjiSubject" , available relations are "amalgamation_subjects, auxiliary_meanings, component_subjects, meanings, readings, visually_similar_subjects")) } ; (@ field_module ; amalgamation_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: auxiliary_meaning :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; component_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_meaning :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; readings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: kanji_reading :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; visually_similar_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; amalgamation_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: amalgamation_subjects :: Include :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; amalgamation_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: amalgamation_subjects :: Include :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: auxiliary_meanings :: Include :: $ selection_mode ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: auxiliary_meaning :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: auxiliary_meanings :: Include :: Fetch ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; component_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: component_subjects :: Include :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: component_subjects :: Include :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: meanings :: Include :: $ selection_mode ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_meaning :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: meanings :: Include :: Fetch ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; readings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: readings :: Include :: $ selection_mode ($ crate :: prisma :: kanji_reading :: ManyArgs :: new ($ crate :: prisma :: kanji_reading :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: kanji_reading :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; readings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: readings :: Include :: Fetch ($ crate :: prisma :: kanji_reading :: ManyArgs :: new ($ crate :: prisma :: kanji_reading :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; visually_similar_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: visually_similar_subjects :: Include :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; visually_similar_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: kanji_subject :: IncludeParam > :: into ($ crate :: prisma :: kanji_subject :: visually_similar_subjects :: Include :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: kanji_subject :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; amalgamation_subjects) => { "amalgamation_subjects" } ; (@ field_serde_name ; auxiliary_meanings) => { "auxiliary_meanings" } ; (@ field_serde_name ; characters) => { "characters" } ; (@ field_serde_name ; component_subjects) => { "component_subjects" } ; (@ field_serde_name ; lesson_position) => { "lesson_position" } ; (@ field_serde_name ; level) => { "level" } ; (@ field_serde_name ; meaning_hint) => { "meaning_hint" } ; (@ field_serde_name ; meaning_mnemonic) => { "meaning_mnemonic" } ; (@ field_serde_name ; meanings) => { "meanings" } ; (@ field_serde_name ; reading_hint) => { "reading_hint" } ; (@ field_serde_name ; reading_mnemonic) => { "reading_mnemonic" } ; (@ field_serde_name ; readings) => { "readings" } ; (@ field_serde_name ; visually_similar_subjects) => { "visually_similar_subjects" } ; }
    pub use _include_kanji_subject as include;
    pub enum IncludeParam {
        Id(id::Include),
        AmalgamationSubjects(amalgamation_subjects::Include),
        AuxiliaryMeanings(auxiliary_meanings::Include),
        Characters(characters::Include),
        ComponentSubjects(component_subjects::Include),
        LessonPosition(lesson_position::Include),
        Level(level::Include),
        MeaningHint(meaning_hint::Include),
        MeaningMnemonic(meaning_mnemonic::Include),
        Meanings(meanings::Include),
        ReadingHint(reading_hint::Include),
        ReadingMnemonic(reading_mnemonic::Include),
        Readings(readings::Include),
        VisuallySimilarSubjects(visually_similar_subjects::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AmalgamationSubjects(data) => data.to_selection(),
                Self::AuxiliaryMeanings(data) => data.to_selection(),
                Self::Characters(data) => data.to_selection(),
                Self::ComponentSubjects(data) => data.to_selection(),
                Self::LessonPosition(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::MeaningHint(data) => data.to_selection(),
                Self::MeaningMnemonic(data) => data.to_selection(),
                Self::Meanings(data) => data.to_selection(),
                Self::ReadingHint(data) => data.to_selection(),
                Self::ReadingMnemonic(data) => data.to_selection(),
                Self::Readings(data) => data.to_selection(),
                Self::VisuallySimilarSubjects(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "amalgamation_subjects")]
        pub amalgamation_subjects: Option<Vec<super::subject_index::Data>>,
        #[serde(rename = "auxiliary_meanings")]
        pub auxiliary_meanings: Option<Vec<super::auxiliary_meaning::Data>>,
        #[serde(rename = "characters")]
        pub characters: String,
        #[serde(rename = "component_subjects")]
        pub component_subjects: Option<Vec<super::subject_index::Data>>,
        #[serde(rename = "lesson_position")]
        pub lesson_position: i32,
        #[serde(rename = "level")]
        pub level: i32,
        #[serde(rename = "meaning_hint")]
        pub meaning_hint: String,
        #[serde(rename = "meaning_mnemonic")]
        pub meaning_mnemonic: String,
        #[serde(rename = "meanings")]
        pub meanings: Option<Vec<super::subject_meaning::Data>>,
        #[serde(rename = "reading_hint")]
        pub reading_hint: String,
        #[serde(rename = "reading_mnemonic")]
        pub reading_mnemonic: String,
        #[serde(rename = "readings")]
        pub readings: Option<Vec<super::kanji_reading::Data>>,
        #[serde(rename = "visually_similar_subjects")]
        pub visually_similar_subjects: Option<Vec<super::subject_index::Data>>,
    }
    impl Data {
        pub fn amalgamation_subjects(
            &self,
        ) -> Result<&Vec<super::subject_index::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.amalgamation_subjects.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    amalgamation_subjects
                )),
            )
        }
        pub fn auxiliary_meanings(
            &self,
        ) -> Result<
            &Vec<super::auxiliary_meaning::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.auxiliary_meanings.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(auxiliary_meanings)),
            )
        }
        pub fn component_subjects(
            &self,
        ) -> Result<&Vec<super::subject_index::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.component_subjects.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(component_subjects)),
            )
        }
        pub fn meanings(
            &self,
        ) -> Result<&Vec<super::subject_meaning::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.meanings
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(meanings),
                ))
        }
        pub fn readings(
            &self,
        ) -> Result<&Vec<super::kanji_reading::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.readings
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(readings),
                ))
        }
        pub fn visually_similar_subjects(
            &self,
        ) -> Result<&Vec<super::subject_index::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.visually_similar_subjects.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    visually_similar_subjects
                )),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        AmalgamationSubjects(super::subject_index::ManyArgs),
        AuxiliaryMeanings(super::auxiliary_meaning::ManyArgs),
        ComponentSubjects(super::subject_index::ManyArgs),
        Meanings(super::subject_meaning::ManyArgs),
        Readings(super::kanji_reading::ManyArgs),
        VisuallySimilarSubjects(super::subject_index::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::AmalgamationSubjects(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_index::_outputs());
                    let mut builder =
                        ::prisma_client_rust::Selection::builder("amalgamation_subjects");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::AuxiliaryMeanings(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::auxiliary_meaning::_outputs());
                    let mut builder =
                        ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::ComponentSubjects(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_index::_outputs());
                    let mut builder =
                        ::prisma_client_rust::Selection::builder("component_subjects");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Meanings(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_meaning::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("meanings");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Readings(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::kanji_reading::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("readings");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::VisuallySimilarSubjects(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_index::_outputs());
                    let mut builder =
                        ::prisma_client_rust::Selection::builder("visually_similar_subjects");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        ConnectAmalgamationSubjects(Vec<super::subject_index::UniqueWhereParam>),
        DisconnectAmalgamationSubjects(Vec<super::subject_index::UniqueWhereParam>),
        SetAmalgamationSubjects(Vec<super::subject_index::UniqueWhereParam>),
        ConnectAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        DisconnectAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        SetAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        SetCharacters(String),
        ConnectComponentSubjects(Vec<super::subject_index::UniqueWhereParam>),
        DisconnectComponentSubjects(Vec<super::subject_index::UniqueWhereParam>),
        SetComponentSubjects(Vec<super::subject_index::UniqueWhereParam>),
        SetLessonPosition(i32),
        IncrementLessonPosition(i32),
        DecrementLessonPosition(i32),
        MultiplyLessonPosition(i32),
        DivideLessonPosition(i32),
        SetLevel(i32),
        IncrementLevel(i32),
        DecrementLevel(i32),
        MultiplyLevel(i32),
        DivideLevel(i32),
        SetMeaningHint(String),
        SetMeaningMnemonic(String),
        ConnectMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
        DisconnectMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
        SetMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
        SetReadingHint(String),
        SetReadingMnemonic(String),
        ConnectReadings(Vec<super::kanji_reading::UniqueWhereParam>),
        DisconnectReadings(Vec<super::kanji_reading::UniqueWhereParam>),
        SetReadings(Vec<super::kanji_reading::UniqueWhereParam>),
        ConnectVisuallySimilarSubjects(Vec<super::subject_index::UniqueWhereParam>),
        DisconnectVisuallySimilarSubjects(Vec<super::subject_index::UniqueWhereParam>),
        SetVisuallySimilarSubjects(Vec<super::subject_index::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectAmalgamationSubjects(where_params) => (
                    "amalgamation_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAmalgamationSubjects(where_params) => (
                    "amalgamation_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAmalgamationSubjects(where_params) => (
                    "amalgamation_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetCharacters(value) => (
                    "characters".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectComponentSubjects(where_params) => (
                    "component_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComponentSubjects(where_params) => (
                    "component_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComponentSubjects(where_params) => (
                    "component_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMeaningHint(value) => (
                    "meaning_hint".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMeaningMnemonic(value) => (
                    "meaning_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReadingHint(value) => (
                    "reading_hint".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetReadingMnemonic(value) => (
                    "reading_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectReadings(where_params) => (
                    "readings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_reading::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectReadings(where_params) => (
                    "readings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_reading::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReadings(where_params) => (
                    "readings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::kanji_reading::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectVisuallySimilarSubjects(where_params) => (
                    "visually_similar_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectVisuallySimilarSubjects(where_params) => (
                    "visually_similar_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetVisuallySimilarSubjects(where_params) => (
                    "visually_similar_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Characters(::prisma_client_rust::Direction),
        LessonPosition(::prisma_client_rust::Direction),
        Level(::prisma_client_rust::Direction),
        MeaningHint(::prisma_client_rust::Direction),
        MeaningMnemonic(::prisma_client_rust::Direction),
        ReadingHint(::prisma_client_rust::Direction),
        ReadingMnemonic(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Characters(direction) => (
                    "characters".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LessonPosition(direction) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Level(direction) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MeaningHint(direction) => (
                    "meaning_hint".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MeaningMnemonic(direction) => (
                    "meaning_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReadingHint(direction) => (
                    "reading_hint".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReadingMnemonic(direction) => (
                    "reading_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        AmalgamationSubjectsSome(Vec<super::subject_index::WhereParam>),
        AmalgamationSubjectsEvery(Vec<super::subject_index::WhereParam>),
        AmalgamationSubjectsNone(Vec<super::subject_index::WhereParam>),
        AuxiliaryMeaningsSome(Vec<super::auxiliary_meaning::WhereParam>),
        AuxiliaryMeaningsEvery(Vec<super::auxiliary_meaning::WhereParam>),
        AuxiliaryMeaningsNone(Vec<super::auxiliary_meaning::WhereParam>),
        CharactersEquals(String),
        CharactersInVec(Vec<String>),
        CharactersNotInVec(Vec<String>),
        CharactersLt(String),
        CharactersLte(String),
        CharactersGt(String),
        CharactersGte(String),
        CharactersContains(String),
        CharactersStartsWith(String),
        CharactersEndsWith(String),
        CharactersMode(QueryMode),
        CharactersNot(String),
        ComponentSubjectsSome(Vec<super::subject_index::WhereParam>),
        ComponentSubjectsEvery(Vec<super::subject_index::WhereParam>),
        ComponentSubjectsNone(Vec<super::subject_index::WhereParam>),
        LessonPositionEquals(i32),
        LessonPositionInVec(Vec<i32>),
        LessonPositionNotInVec(Vec<i32>),
        LessonPositionLt(i32),
        LessonPositionLte(i32),
        LessonPositionGt(i32),
        LessonPositionGte(i32),
        LessonPositionNot(i32),
        LevelEquals(i32),
        LevelInVec(Vec<i32>),
        LevelNotInVec(Vec<i32>),
        LevelLt(i32),
        LevelLte(i32),
        LevelGt(i32),
        LevelGte(i32),
        LevelNot(i32),
        MeaningHintEquals(String),
        MeaningHintInVec(Vec<String>),
        MeaningHintNotInVec(Vec<String>),
        MeaningHintLt(String),
        MeaningHintLte(String),
        MeaningHintGt(String),
        MeaningHintGte(String),
        MeaningHintContains(String),
        MeaningHintStartsWith(String),
        MeaningHintEndsWith(String),
        MeaningHintMode(QueryMode),
        MeaningHintNot(String),
        MeaningMnemonicEquals(String),
        MeaningMnemonicInVec(Vec<String>),
        MeaningMnemonicNotInVec(Vec<String>),
        MeaningMnemonicLt(String),
        MeaningMnemonicLte(String),
        MeaningMnemonicGt(String),
        MeaningMnemonicGte(String),
        MeaningMnemonicContains(String),
        MeaningMnemonicStartsWith(String),
        MeaningMnemonicEndsWith(String),
        MeaningMnemonicMode(QueryMode),
        MeaningMnemonicNot(String),
        MeaningsSome(Vec<super::subject_meaning::WhereParam>),
        MeaningsEvery(Vec<super::subject_meaning::WhereParam>),
        MeaningsNone(Vec<super::subject_meaning::WhereParam>),
        ReadingHintEquals(String),
        ReadingHintInVec(Vec<String>),
        ReadingHintNotInVec(Vec<String>),
        ReadingHintLt(String),
        ReadingHintLte(String),
        ReadingHintGt(String),
        ReadingHintGte(String),
        ReadingHintContains(String),
        ReadingHintStartsWith(String),
        ReadingHintEndsWith(String),
        ReadingHintMode(QueryMode),
        ReadingHintNot(String),
        ReadingMnemonicEquals(String),
        ReadingMnemonicInVec(Vec<String>),
        ReadingMnemonicNotInVec(Vec<String>),
        ReadingMnemonicLt(String),
        ReadingMnemonicLte(String),
        ReadingMnemonicGt(String),
        ReadingMnemonicGte(String),
        ReadingMnemonicContains(String),
        ReadingMnemonicStartsWith(String),
        ReadingMnemonicEndsWith(String),
        ReadingMnemonicMode(QueryMode),
        ReadingMnemonicNot(String),
        ReadingsSome(Vec<super::kanji_reading::WhereParam>),
        ReadingsEvery(Vec<super::kanji_reading::WhereParam>),
        ReadingsNone(Vec<super::kanji_reading::WhereParam>),
        VisuallySimilarSubjectsSome(Vec<super::subject_index::WhereParam>),
        VisuallySimilarSubjectsEvery(Vec<super::subject_index::WhereParam>),
        VisuallySimilarSubjectsNone(Vec<super::subject_index::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::AmalgamationSubjectsSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "amalgamation_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AmalgamationSubjectsEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "amalgamation_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AmalgamationSubjectsNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "amalgamation_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AuxiliaryMeaningsSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AuxiliaryMeaningsEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AuxiliaryMeaningsNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::CharactersEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CharactersNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CharactersLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::CharactersNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ComponentSubjectsSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "component_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::ComponentSubjectsEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "component_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::ComponentSubjectsNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "component_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::LessonPositionEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LessonPositionNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LessonPositionLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LevelNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LevelLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::MeaningHintEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningHintInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningHintNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningHintLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningHintLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningHintGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningHintGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningHintContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningHintStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningHintEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningHintMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::MeaningHintNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningMnemonicNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningMnemonicLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicStartsWith(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "meaning_mnemonic",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )]),
                    )
                }
                Self::MeaningMnemonicEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::MeaningMnemonicNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningsSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningsEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningsNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingHintEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingHintInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingHintNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingHintLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingHintLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingHintGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingHintGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingHintContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingHintStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingHintEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingHintMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ReadingHintNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_hint",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingMnemonicNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingMnemonicLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicStartsWith(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "reading_mnemonic",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )]),
                    )
                }
                Self::ReadingMnemonicEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ReadingMnemonicNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingsSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "readings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingsEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "readings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingsNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "readings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VisuallySimilarSubjectsSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "visually_similar_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VisuallySimilarSubjectsEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "visually_similar_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VisuallySimilarSubjectsNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "visually_similar_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: i32,
            characters: String,
            lesson_position: i32,
            level: i32,
            meaning_hint: String,
            meaning_mnemonic: String,
            reading_hint: String,
            reading_mnemonic: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(characters::set(characters));
            _params.push(lesson_position::set(lesson_position));
            _params.push(level::set(level));
            _params.push(meaning_hint::set(meaning_hint));
            _params.push(meaning_mnemonic::set(meaning_mnemonic));
            _params.push(reading_hint::set(reading_hint));
            _params.push(reading_mnemonic::set(reading_mnemonic));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(
                i32,
                String,
                i32,
                i32,
                String,
                String,
                String,
                String,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        id,
                        characters,
                        lesson_position,
                        level,
                        meaning_hint,
                        meaning_mnemonic,
                        reading_hint,
                        reading_mnemonic,
                        mut _params,
                    )| {
                        _params.push(id::set(id));
                        _params.push(characters::set(characters));
                        _params.push(lesson_position::set(lesson_position));
                        _params.push(level::set(level));
                        _params.push(meaning_hint::set(meaning_hint));
                        _params.push(meaning_mnemonic::set(meaning_mnemonic));
                        _params.push(reading_hint::set(reading_hint));
                        _params.push(reading_mnemonic::set(reading_mnemonic));
                        _params
                    },
                )
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                id,
                characters,
                lesson_position,
                level,
                meaning_hint,
                meaning_mnemonic,
                reading_hint,
                reading_mnemonic,
                mut _params,
            ): (
                i32,
                String,
                i32,
                i32,
                String,
                String,
                String,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(characters::set(characters));
            _params.push(lesson_position::set(lesson_position));
            _params.push(level::set(level));
            _params.push(meaning_hint::set(meaning_hint));
            _params.push(meaning_mnemonic::set(meaning_mnemonic));
            _params.push(reading_hint::set(reading_hint));
            _params.push(reading_mnemonic::set(reading_mnemonic));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("KanjiSubject", _outputs()),
                vec![],
            )
        }
    }
}
pub mod context_sentence {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod en {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EnEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::En(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EnInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EnNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EnLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EnLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EnGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EnGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EnContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EnStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EnEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::EnMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EnNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEn(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::En(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("en").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::En(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("en").build()
            }
        }
    }
    pub mod ja {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::JaEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Ja(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::JaInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::JaNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::JaLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::JaLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::JaGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::JaGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::JaContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::JaStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::JaEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::JaMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::JaNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetJa(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Ja(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("ja").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Ja(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("ja").build()
            }
        }
    }
    pub mod vocabulary_subject {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabularySubjectIs(value)
        }
        pub fn is_not(value: Vec<vocabulary_subject::WhereParam>) -> WhereParam {
            WhereParam::VocabularySubjectIsNot(value)
        }
        pub struct Fetch(pub vocabulary_subject::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<vocabulary_subject::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::VocabularySubject(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(vocabulary_subject::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: vocabulary_subject::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectVocabularySubject
        }
        pub struct Connect(vocabulary_subject::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectVocabularySubject(value.0)
            }
        }
        pub enum Include {
            Select(Vec<vocabulary_subject::SelectParam>),
            Include(Vec<vocabulary_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabularySubject(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("VocabularySubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vocabulary_subject::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<vocabulary_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<vocabulary_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<vocabulary_subject::SelectParam>),
            Include(Vec<vocabulary_subject::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabularySubject(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("VocabularySubject");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(vocabulary_subject::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<vocabulary_subject::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<vocabulary_subject::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod vocabulary_subject_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::VocabularySubjectId(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::VocabularySubjectIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::VocabularySubjectIdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementVocabularySubjectId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementVocabularySubjectId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyVocabularySubjectId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideVocabularySubjectId(value)
        }
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetVocabularySubjectId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VocabularySubjectId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("vocabularySubjectId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VocabularySubjectId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("vocabularySubjectId").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["id", "en", "ja", "vocabularySubjectId"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        en: String,
        ja: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (en, ja, _params)
    }
    #[macro_export]
    macro_rules ! _select_context_sentence { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: context_sentence :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: context_sentence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: context_sentence :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: context_sentence :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: context_sentence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: context_sentence :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , en , ja , vocabulary_subject , vocabulary_subject_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: context_sentence :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (en) , stringify ! (ja) , stringify ! (vocabulary_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: context_sentence :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: context_sentence :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: context_sentence :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: context_sentence :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: context_sentence :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "en" , "ja" , "VocabularySubject" , "vocabularySubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: context_sentence :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; en) => { String } ; (@ field_type ; ja) => { String } ; (@ field_type ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject) => { Option < crate :: prisma :: vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject_id) => { Option < i32 > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "ContextSentence" , available fields are "id, en, ja, vocabulary_subject, vocabulary_subject_id")) } ; (@ field_module ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: context_sentence :: SelectParam > :: into ($ crate :: prisma :: context_sentence :: id :: Select) } ; (@ selection_field_to_selection_param ; en) => { Into :: < $ crate :: prisma :: context_sentence :: SelectParam > :: into ($ crate :: prisma :: context_sentence :: en :: Select) } ; (@ selection_field_to_selection_param ; ja) => { Into :: < $ crate :: prisma :: context_sentence :: SelectParam > :: into ($ crate :: prisma :: context_sentence :: ja :: Select) } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: context_sentence :: SelectParam > :: into ($ crate :: prisma :: context_sentence :: vocabulary_subject :: Select :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: context_sentence :: SelectParam > :: into ($ crate :: prisma :: context_sentence :: vocabulary_subject :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; vocabulary_subject_id) => { Into :: < $ crate :: prisma :: context_sentence :: SelectParam > :: into ($ crate :: prisma :: context_sentence :: vocabulary_subject_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: context_sentence :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; en) => { "en" } ; (@ field_serde_name ; ja) => { "ja" } ; (@ field_serde_name ; vocabulary_subject) => { "VocabularySubject" } ; (@ field_serde_name ; vocabulary_subject_id) => { "vocabularySubjectId" } ; }
    pub use _select_context_sentence as select;
    pub enum SelectParam {
        Id(id::Select),
        En(en::Select),
        Ja(ja::Select),
        VocabularySubject(vocabulary_subject::Select),
        VocabularySubjectId(vocabulary_subject_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::En(data) => data.to_selection(),
                Self::Ja(data) => data.to_selection(),
                Self::VocabularySubject(data) => data.to_selection(),
                Self::VocabularySubjectId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_context_sentence { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: context_sentence :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: context_sentence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: context_sentence :: _outputs () ; selections . extend ($ crate :: prisma :: context_sentence :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: context_sentence :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: context_sentence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: context_sentence :: _outputs () ; selections . extend ($ crate :: prisma :: context_sentence :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { vocabulary_subject } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : String , pub en : String , pub ja : String , pub vocabulary_subject_id : Option < i32 > , $ (pub $ field : $ crate :: prisma :: context_sentence :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (en) , stringify ! (ja) , stringify ! (vocabulary_subject_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , en , ja , vocabulary_subject_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; en) , ", " , $ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; ja) , ", " , $ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; vocabulary_subject_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; en) => Ok (Field :: en) , $ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; ja) => Ok (Field :: ja) , $ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; vocabulary_subject_id) => Ok (Field :: vocabulary_subject_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut en = None ; let mut ja = None ; let mut vocabulary_subject_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: en => { if en . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; en))) ; } en = Some (map . next_value () ?) ; } Field :: ja => { if ja . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; ja))) ; } ja = Some (map . next_value () ?) ; } Field :: vocabulary_subject_id => { if vocabulary_subject_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; vocabulary_subject_id))) ; } vocabulary_subject_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; id))) ? ; let en = en . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; en))) ? ; let ja = ja . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; ja))) ? ; let vocabulary_subject_id = vocabulary_subject_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: context_sentence :: include ! (@ field_serde_name ; vocabulary_subject_id))) ? ; Ok (Data { id , en , ja , vocabulary_subject_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "en" , "ja" , "VocabularySubject" , "vocabularySubjectId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: context_sentence :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < vocabulary_subject :: Data > } ; (@ field_type ; vocabulary_subject) => { Option < crate :: prisma :: vocabulary_subject :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ContextSentence" , available relations are "vocabulary_subject")) } ; (@ field_module ; vocabulary_subject : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_subject :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: context_sentence :: IncludeParam > :: into ($ crate :: prisma :: context_sentence :: vocabulary_subject :: Include :: $ selection_mode ($ crate :: prisma :: vocabulary_subject :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; vocabulary_subject $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: context_sentence :: IncludeParam > :: into ($ crate :: prisma :: context_sentence :: vocabulary_subject :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: context_sentence :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; en) => { "en" } ; (@ field_serde_name ; ja) => { "ja" } ; (@ field_serde_name ; vocabulary_subject) => { "VocabularySubject" } ; (@ field_serde_name ; vocabulary_subject_id) => { "vocabularySubjectId" } ; }
    pub use _include_context_sentence as include;
    pub enum IncludeParam {
        Id(id::Include),
        En(en::Include),
        Ja(ja::Include),
        VocabularySubject(vocabulary_subject::Include),
        VocabularySubjectId(vocabulary_subject_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::En(data) => data.to_selection(),
                Self::Ja(data) => data.to_selection(),
                Self::VocabularySubject(data) => data.to_selection(),
                Self::VocabularySubjectId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "en")]
        pub en: String,
        #[serde(rename = "ja")]
        pub ja: String,
        #[serde(
            rename = "VocabularySubject",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub vocabulary_subject: Option<Option<Box<super::vocabulary_subject::Data>>>,
        #[serde(rename = "vocabularySubjectId")]
        pub vocabulary_subject_id: Option<i32>,
    }
    impl Data {
        pub fn vocabulary_subject(
            &self,
        ) -> Result<
            Option<&super::vocabulary_subject::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.vocabulary_subject
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(vocabulary_subject),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        VocabularySubject(super::vocabulary_subject::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::VocabularySubject(args) => {
                    let mut selections = super::vocabulary_subject::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("VocabularySubject");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetEn(String),
        SetJa(String),
        ConnectVocabularySubject(super::vocabulary_subject::UniqueWhereParam),
        DisconnectVocabularySubject,
        SetVocabularySubjectId(Option<i32>),
        IncrementVocabularySubjectId(i32),
        DecrementVocabularySubjectId(i32),
        MultiplyVocabularySubjectId(i32),
        DivideVocabularySubjectId(i32),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEn(value) => (
                    "en".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetJa(value) => (
                    "ja".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectVocabularySubject(where_param) => (
                    "VocabularySubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::vocabulary_subject::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectVocabularySubject => (
                    "VocabularySubject".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideVocabularySubjectId(value) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        En(::prisma_client_rust::Direction),
        Ja(::prisma_client_rust::Direction),
        VocabularySubjectId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::En(direction) => (
                    "en".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Ja(direction) => (
                    "ja".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::VocabularySubjectId(direction) => (
                    "vocabularySubjectId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        EnEquals(String),
        EnInVec(Vec<String>),
        EnNotInVec(Vec<String>),
        EnLt(String),
        EnLte(String),
        EnGt(String),
        EnGte(String),
        EnContains(String),
        EnStartsWith(String),
        EnEndsWith(String),
        EnMode(QueryMode),
        EnNot(String),
        JaEquals(String),
        JaInVec(Vec<String>),
        JaNotInVec(Vec<String>),
        JaLt(String),
        JaLte(String),
        JaGt(String),
        JaGte(String),
        JaContains(String),
        JaStartsWith(String),
        JaEndsWith(String),
        JaMode(QueryMode),
        JaNot(String),
        VocabularySubjectIs(Vec<super::vocabulary_subject::WhereParam>),
        VocabularySubjectIsNot(Vec<super::vocabulary_subject::WhereParam>),
        VocabularySubjectIdEquals(Option<i32>),
        VocabularySubjectIdInVec(Vec<i32>),
        VocabularySubjectIdNotInVec(Vec<i32>),
        VocabularySubjectIdLt(i32),
        VocabularySubjectIdLte(i32),
        VocabularySubjectIdGt(i32),
        VocabularySubjectIdGte(i32),
        VocabularySubjectIdNot(i32),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::EnNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::EnLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EnMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::EnNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "en",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::JaNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::JaLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::JaMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::JaNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ja",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::VocabularySubjectIs(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "VocabularySubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "is".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIsNot(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "VocabularySubject",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isNot".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdEquals(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                        )]),
                    )
                }
                Self::VocabularySubjectIdInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdNotInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "vocabularySubjectId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::VocabularySubjectIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::VocabularySubjectIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "vocabularySubjectId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _where,
            )
        }
        pub fn create(self, en: String, ja: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(en::set(en));
            _params.push(ja::set(ja));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(en, ja, mut _params)| {
                    _params.push(en::set(en));
                    _params.push(ja::set(ja));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (en, ja, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(en::set(en));
            _params.push(ja::set(ja));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("ContextSentence", _outputs()),
                vec![],
            )
        }
    }
}
pub mod vocabulary_subject {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod auxiliary_meanings {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsSome(value)
        }
        pub fn every(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsEvery(value)
        }
        pub fn none(value: Vec<auxiliary_meaning::WhereParam>) -> WhereParam {
            WhereParam::AuxiliaryMeaningsNone(value)
        }
        pub struct Fetch(pub auxiliary_meaning::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<auxiliary_meaning::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: auxiliary_meaning::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: auxiliary_meaning::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::AuxiliaryMeanings(fetch.0)
            }
        }
        pub fn fetch(params: Vec<auxiliary_meaning::WhereParam>) -> Fetch {
            Fetch(auxiliary_meaning::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAuxiliaryMeanings(params)
        }
        pub fn set(params: Vec<auxiliary_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::SetAuxiliaryMeanings(params)
        }
        pub struct Connect(pub Vec<auxiliary_meaning::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAuxiliaryMeanings(value.0)
            }
        }
        pub enum Include {
            Select(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::SelectParam>,
            ),
            Include(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::IncludeParam>,
            ),
            Fetch(auxiliary_meaning::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AuxiliaryMeanings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = auxiliary_meaning::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(auxiliary_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::SelectParam>,
            ),
            Include(
                auxiliary_meaning::ManyArgs,
                Vec<auxiliary_meaning::IncludeParam>,
            ),
            Fetch(auxiliary_meaning::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AuxiliaryMeanings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(auxiliary_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: auxiliary_meaning::ManyArgs,
                nested_selections: Vec<auxiliary_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod characters {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::CharactersEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Characters(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CharactersInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CharactersNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CharactersLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CharactersLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CharactersGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CharactersGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CharactersContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CharactersStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CharactersEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::CharactersMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CharactersNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCharacters(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Characters(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("characters").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Characters(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("characters").build()
            }
        }
    }
    pub mod component_subjects {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::ComponentSubjectsSome(value)
        }
        pub fn every(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::ComponentSubjectsEvery(value)
        }
        pub fn none(value: Vec<subject_index::WhereParam>) -> WhereParam {
            WhereParam::ComponentSubjectsNone(value)
        }
        pub struct Fetch(pub subject_index::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_index::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_index::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_index::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::ComponentSubjects(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_index::WhereParam>) -> Fetch {
            Fetch(subject_index::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_index::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectComponentSubjects(params)
        }
        pub fn set(params: Vec<subject_index::UniqueWhereParam>) -> SetParam {
            SetParam::SetComponentSubjects(params)
        }
        pub struct Connect(pub Vec<subject_index::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectComponentSubjects(value.0)
            }
        }
        pub enum Include {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentSubjects(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("component_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_index::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(subject_index::ManyArgs, Vec<subject_index::SelectParam>),
            Include(subject_index::ManyArgs, Vec<subject_index::IncludeParam>),
            Fetch(subject_index::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentSubjects(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("component_subjects");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_index::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_index::ManyArgs,
                nested_selections: Vec<subject_index::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod context_sentences {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<context_sentence::WhereParam>) -> WhereParam {
            WhereParam::ContextSentencesSome(value)
        }
        pub fn every(value: Vec<context_sentence::WhereParam>) -> WhereParam {
            WhereParam::ContextSentencesEvery(value)
        }
        pub fn none(value: Vec<context_sentence::WhereParam>) -> WhereParam {
            WhereParam::ContextSentencesNone(value)
        }
        pub struct Fetch(pub context_sentence::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<context_sentence::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: context_sentence::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: context_sentence::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::ContextSentences(fetch.0)
            }
        }
        pub fn fetch(params: Vec<context_sentence::WhereParam>) -> Fetch {
            Fetch(context_sentence::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<context_sentence::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<context_sentence::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectContextSentences(params)
        }
        pub fn set(params: Vec<context_sentence::UniqueWhereParam>) -> SetParam {
            SetParam::SetContextSentences(params)
        }
        pub struct Connect(pub Vec<context_sentence::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectContextSentences(value.0)
            }
        }
        pub enum Include {
            Select(
                context_sentence::ManyArgs,
                Vec<context_sentence::SelectParam>,
            ),
            Include(
                context_sentence::ManyArgs,
                Vec<context_sentence::IncludeParam>,
            ),
            Fetch(context_sentence::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ContextSentences(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("context_sentences");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = context_sentence::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(context_sentence::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: context_sentence::ManyArgs,
                nested_selections: Vec<context_sentence::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: context_sentence::ManyArgs,
                nested_selections: Vec<context_sentence::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                context_sentence::ManyArgs,
                Vec<context_sentence::SelectParam>,
            ),
            Include(
                context_sentence::ManyArgs,
                Vec<context_sentence::IncludeParam>,
            ),
            Fetch(context_sentence::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ContextSentences(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("context_sentences");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(context_sentence::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: context_sentence::ManyArgs,
                nested_selections: Vec<context_sentence::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: context_sentence::ManyArgs,
                nested_selections: Vec<context_sentence::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod lesson_position {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::LessonPositionEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LessonPosition(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LessonPositionInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LessonPositionNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::LessonPositionLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::LessonPositionLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::LessonPositionGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::LessonPositionGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::LessonPositionNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementLessonPosition(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementLessonPosition(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyLessonPosition(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideLessonPosition(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLessonPosition(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LessonPosition(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("lesson_position").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LessonPosition(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("lesson_position").build()
            }
        }
    }
    pub mod level {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::LevelEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Level(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LevelInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::LevelNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::LevelLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::LevelLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::LevelGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::LevelGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::LevelNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementLevel(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementLevel(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyLevel(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideLevel(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLevel(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Level(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("level").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Level(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("level").build()
            }
        }
    }
    pub mod meaning_mnemonic {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MeaningMnemonic(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningMnemonicInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MeaningMnemonicNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::MeaningMnemonicMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MeaningMnemonicNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMeaningMnemonic(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MeaningMnemonic(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning_mnemonic").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MeaningMnemonic(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("meaning_mnemonic").build()
            }
        }
    }
    pub mod meanings {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsSome(value)
        }
        pub fn every(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsEvery(value)
        }
        pub fn none(value: Vec<subject_meaning::WhereParam>) -> WhereParam {
            WhereParam::MeaningsNone(value)
        }
        pub struct Fetch(pub subject_meaning::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<subject_meaning::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: subject_meaning::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: subject_meaning::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Meanings(fetch.0)
            }
        }
        pub fn fetch(params: Vec<subject_meaning::WhereParam>) -> Fetch {
            Fetch(subject_meaning::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<subject_meaning::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<subject_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMeanings(params)
        }
        pub fn set(params: Vec<subject_meaning::UniqueWhereParam>) -> SetParam {
            SetParam::SetMeanings(params)
        }
        pub struct Connect(pub Vec<subject_meaning::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectMeanings(value.0)
            }
        }
        pub enum Include {
            Select(subject_meaning::ManyArgs, Vec<subject_meaning::SelectParam>),
            Include(
                subject_meaning::ManyArgs,
                Vec<subject_meaning::IncludeParam>,
            ),
            Fetch(subject_meaning::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Meanings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = subject_meaning::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(subject_meaning::ManyArgs, Vec<subject_meaning::SelectParam>),
            Include(
                subject_meaning::ManyArgs,
                Vec<subject_meaning::IncludeParam>,
            ),
            Fetch(subject_meaning::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Meanings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("meanings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(subject_meaning::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: subject_meaning::ManyArgs,
                nested_selections: Vec<subject_meaning::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod reading_mnemonic {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReadingMnemonic(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingMnemonicInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReadingMnemonicNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ReadingMnemonicMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ReadingMnemonicNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReadingMnemonic(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReadingMnemonic(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading_mnemonic").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReadingMnemonic(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reading_mnemonic").build()
            }
        }
    }
    pub mod readings {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<vocabulary_reading::WhereParam>) -> WhereParam {
            WhereParam::ReadingsSome(value)
        }
        pub fn every(value: Vec<vocabulary_reading::WhereParam>) -> WhereParam {
            WhereParam::ReadingsEvery(value)
        }
        pub fn none(value: Vec<vocabulary_reading::WhereParam>) -> WhereParam {
            WhereParam::ReadingsNone(value)
        }
        pub struct Fetch(pub vocabulary_reading::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<vocabulary_reading::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: vocabulary_reading::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: vocabulary_reading::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Readings(fetch.0)
            }
        }
        pub fn fetch(params: Vec<vocabulary_reading::WhereParam>) -> Fetch {
            Fetch(vocabulary_reading::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<vocabulary_reading::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<vocabulary_reading::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectReadings(params)
        }
        pub fn set(params: Vec<vocabulary_reading::UniqueWhereParam>) -> SetParam {
            SetParam::SetReadings(params)
        }
        pub struct Connect(pub Vec<vocabulary_reading::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectReadings(value.0)
            }
        }
        pub enum Include {
            Select(
                vocabulary_reading::ManyArgs,
                Vec<vocabulary_reading::SelectParam>,
            ),
            Include(
                vocabulary_reading::ManyArgs,
                Vec<vocabulary_reading::IncludeParam>,
            ),
            Fetch(vocabulary_reading::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Readings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("readings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = vocabulary_reading::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(vocabulary_reading::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: vocabulary_reading::ManyArgs,
                nested_selections: Vec<vocabulary_reading::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: vocabulary_reading::ManyArgs,
                nested_selections: Vec<vocabulary_reading::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                vocabulary_reading::ManyArgs,
                Vec<vocabulary_reading::SelectParam>,
            ),
            Include(
                vocabulary_reading::ManyArgs,
                Vec<vocabulary_reading::IncludeParam>,
            ),
            Fetch(vocabulary_reading::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Readings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("readings");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(vocabulary_reading::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: vocabulary_reading::ManyArgs,
                nested_selections: Vec<vocabulary_reading::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: vocabulary_reading::ManyArgs,
                nested_selections: Vec<vocabulary_reading::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "id",
            "characters",
            "lesson_position",
            "level",
            "meaning_mnemonic",
            "reading_mnemonic",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        id: i32,
        characters: String,
        lesson_position: i32,
        level: i32,
        meaning_mnemonic: String,
        reading_mnemonic: String,
        _params: Vec<SetParam>,
    ) -> (i32, String, i32, i32, String, String, Vec<SetParam>) {
        (
            id,
            characters,
            lesson_position,
            level,
            meaning_mnemonic,
            reading_mnemonic,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_vocabulary_subject { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: vocabulary_subject :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: vocabulary_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: vocabulary_subject :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: vocabulary_subject :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: vocabulary_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: vocabulary_subject :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , auxiliary_meanings , characters , component_subjects , context_sentences , lesson_position , level , meaning_mnemonic , meanings , reading_mnemonic , readings } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: vocabulary_subject :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (characters) , stringify ! (lesson_position) , stringify ! (level) , stringify ! (meaning_mnemonic) , stringify ! (reading_mnemonic)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: vocabulary_subject :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: vocabulary_subject :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: vocabulary_subject :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_subject :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_subject :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "auxiliary_meanings" , "characters" , "component_subjects" , "context_sentences" , "lesson_position" , "level" , "meaning_mnemonic" , "meanings" , "reading_mnemonic" , "readings"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: vocabulary_subject :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < auxiliary_meanings :: Data > } ; (@ field_type ; auxiliary_meanings) => { Vec < crate :: prisma :: auxiliary_meaning :: Data > } ; (@ field_type ; characters) => { String } ; (@ field_type ; component_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_subjects :: Data > } ; (@ field_type ; component_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; context_sentences : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < context_sentences :: Data > } ; (@ field_type ; context_sentences) => { Vec < crate :: prisma :: context_sentence :: Data > } ; (@ field_type ; lesson_position) => { i32 } ; (@ field_type ; level) => { i32 } ; (@ field_type ; meaning_mnemonic) => { String } ; (@ field_type ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < meanings :: Data > } ; (@ field_type ; meanings) => { Vec < crate :: prisma :: subject_meaning :: Data > } ; (@ field_type ; reading_mnemonic) => { String } ; (@ field_type ; readings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < readings :: Data > } ; (@ field_type ; readings) => { Vec < crate :: prisma :: vocabulary_reading :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "VocabularySubject" , available fields are "id, auxiliary_meanings, characters, component_subjects, context_sentences, lesson_position, level, meaning_mnemonic, meanings, reading_mnemonic, readings")) } ; (@ field_module ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: auxiliary_meaning :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; component_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; context_sentences : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: context_sentence :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_meaning :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; readings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_reading :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: id :: Select) } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: auxiliary_meanings :: Select :: $ selection_mode ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: auxiliary_meaning :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: auxiliary_meanings :: Select :: Fetch ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; characters) => { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: characters :: Select) } ; (@ selection_field_to_selection_param ; component_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: component_subjects :: Select :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: component_subjects :: Select :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; context_sentences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: context_sentences :: Select :: $ selection_mode ($ crate :: prisma :: context_sentence :: ManyArgs :: new ($ crate :: prisma :: context_sentence :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: context_sentence :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; context_sentences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: context_sentences :: Select :: Fetch ($ crate :: prisma :: context_sentence :: ManyArgs :: new ($ crate :: prisma :: context_sentence :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; lesson_position) => { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: lesson_position :: Select) } ; (@ selection_field_to_selection_param ; level) => { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: level :: Select) } ; (@ selection_field_to_selection_param ; meaning_mnemonic) => { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: meaning_mnemonic :: Select) } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: meanings :: Select :: $ selection_mode ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_meaning :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: meanings :: Select :: Fetch ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; reading_mnemonic) => { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: reading_mnemonic :: Select) } ; (@ selection_field_to_selection_param ; readings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: readings :: Select :: $ selection_mode ($ crate :: prisma :: vocabulary_reading :: ManyArgs :: new ($ crate :: prisma :: vocabulary_reading :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: vocabulary_reading :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; readings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: SelectParam > :: into ($ crate :: prisma :: vocabulary_subject :: readings :: Select :: Fetch ($ crate :: prisma :: vocabulary_reading :: ManyArgs :: new ($ crate :: prisma :: vocabulary_reading :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: vocabulary_subject :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; auxiliary_meanings) => { "auxiliary_meanings" } ; (@ field_serde_name ; characters) => { "characters" } ; (@ field_serde_name ; component_subjects) => { "component_subjects" } ; (@ field_serde_name ; context_sentences) => { "context_sentences" } ; (@ field_serde_name ; lesson_position) => { "lesson_position" } ; (@ field_serde_name ; level) => { "level" } ; (@ field_serde_name ; meaning_mnemonic) => { "meaning_mnemonic" } ; (@ field_serde_name ; meanings) => { "meanings" } ; (@ field_serde_name ; reading_mnemonic) => { "reading_mnemonic" } ; (@ field_serde_name ; readings) => { "readings" } ; }
    pub use _select_vocabulary_subject as select;
    pub enum SelectParam {
        Id(id::Select),
        AuxiliaryMeanings(auxiliary_meanings::Select),
        Characters(characters::Select),
        ComponentSubjects(component_subjects::Select),
        ContextSentences(context_sentences::Select),
        LessonPosition(lesson_position::Select),
        Level(level::Select),
        MeaningMnemonic(meaning_mnemonic::Select),
        Meanings(meanings::Select),
        ReadingMnemonic(reading_mnemonic::Select),
        Readings(readings::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AuxiliaryMeanings(data) => data.to_selection(),
                Self::Characters(data) => data.to_selection(),
                Self::ComponentSubjects(data) => data.to_selection(),
                Self::ContextSentences(data) => data.to_selection(),
                Self::LessonPosition(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::MeaningMnemonic(data) => data.to_selection(),
                Self::Meanings(data) => data.to_selection(),
                Self::ReadingMnemonic(data) => data.to_selection(),
                Self::Readings(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_vocabulary_subject { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: vocabulary_subject :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: vocabulary_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: vocabulary_subject :: _outputs () ; selections . extend ($ crate :: prisma :: vocabulary_subject :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: vocabulary_subject :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: vocabulary_subject :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: vocabulary_subject :: _outputs () ; selections . extend ($ crate :: prisma :: vocabulary_subject :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { auxiliary_meanings , component_subjects , context_sentences , meanings , readings } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : i32 , pub characters : String , pub lesson_position : i32 , pub level : i32 , pub meaning_mnemonic : String , pub reading_mnemonic : String , $ (pub $ field : $ crate :: prisma :: vocabulary_subject :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (characters) , stringify ! (lesson_position) , stringify ! (level) , stringify ! (meaning_mnemonic) , stringify ! (reading_mnemonic)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , characters , lesson_position , level , meaning_mnemonic , reading_mnemonic } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; characters) , ", " , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; lesson_position) , ", " , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; level) , ", " , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; meaning_mnemonic) , ", " , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; reading_mnemonic) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; characters) => Ok (Field :: characters) , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; lesson_position) => Ok (Field :: lesson_position) , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; level) => Ok (Field :: level) , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; meaning_mnemonic) => Ok (Field :: meaning_mnemonic) , $ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; reading_mnemonic) => Ok (Field :: reading_mnemonic) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut characters = None ; let mut lesson_position = None ; let mut level = None ; let mut meaning_mnemonic = None ; let mut reading_mnemonic = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: characters => { if characters . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; characters))) ; } characters = Some (map . next_value () ?) ; } Field :: lesson_position => { if lesson_position . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; lesson_position))) ; } lesson_position = Some (map . next_value () ?) ; } Field :: level => { if level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; level))) ; } level = Some (map . next_value () ?) ; } Field :: meaning_mnemonic => { if meaning_mnemonic . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; meaning_mnemonic))) ; } meaning_mnemonic = Some (map . next_value () ?) ; } Field :: reading_mnemonic => { if reading_mnemonic . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; reading_mnemonic))) ; } reading_mnemonic = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; id))) ? ; let characters = characters . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; characters))) ? ; let lesson_position = lesson_position . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; lesson_position))) ? ; let level = level . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; level))) ? ; let meaning_mnemonic = meaning_mnemonic . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; meaning_mnemonic))) ? ; let reading_mnemonic = reading_mnemonic . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: vocabulary_subject :: include ! (@ field_serde_name ; reading_mnemonic))) ? ; Ok (Data { id , characters , lesson_position , level , meaning_mnemonic , reading_mnemonic , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "auxiliary_meanings" , "characters" , "component_subjects" , "context_sentences" , "lesson_position" , "level" , "meaning_mnemonic" , "meanings" , "reading_mnemonic" , "readings"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: vocabulary_subject :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < auxiliary_meanings :: Data > } ; (@ field_type ; auxiliary_meanings) => { Vec < crate :: prisma :: auxiliary_meaning :: Data > } ; (@ field_type ; component_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_subjects :: Data > } ; (@ field_type ; component_subjects) => { Vec < crate :: prisma :: subject_index :: Data > } ; (@ field_type ; context_sentences : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < context_sentences :: Data > } ; (@ field_type ; context_sentences) => { Vec < crate :: prisma :: context_sentence :: Data > } ; (@ field_type ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < meanings :: Data > } ; (@ field_type ; meanings) => { Vec < crate :: prisma :: subject_meaning :: Data > } ; (@ field_type ; readings : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < readings :: Data > } ; (@ field_type ; readings) => { Vec < crate :: prisma :: vocabulary_reading :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "VocabularySubject" , available relations are "auxiliary_meanings, component_subjects, context_sentences, meanings, readings")) } ; (@ field_module ; auxiliary_meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: auxiliary_meaning :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; component_subjects : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_index :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; context_sentences : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: context_sentence :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; meanings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: subject_meaning :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; readings : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: vocabulary_reading :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: auxiliary_meanings :: Include :: $ selection_mode ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: auxiliary_meaning :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; auxiliary_meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: auxiliary_meanings :: Include :: Fetch ($ crate :: prisma :: auxiliary_meaning :: ManyArgs :: new ($ crate :: prisma :: auxiliary_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; component_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: component_subjects :: Include :: $ selection_mode ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_index :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_subjects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: component_subjects :: Include :: Fetch ($ crate :: prisma :: subject_index :: ManyArgs :: new ($ crate :: prisma :: subject_index :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; context_sentences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: context_sentences :: Include :: $ selection_mode ($ crate :: prisma :: context_sentence :: ManyArgs :: new ($ crate :: prisma :: context_sentence :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: context_sentence :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; context_sentences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: context_sentences :: Include :: Fetch ($ crate :: prisma :: context_sentence :: ManyArgs :: new ($ crate :: prisma :: context_sentence :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: meanings :: Include :: $ selection_mode ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: subject_meaning :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; meanings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: meanings :: Include :: Fetch ($ crate :: prisma :: subject_meaning :: ManyArgs :: new ($ crate :: prisma :: subject_meaning :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; readings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: readings :: Include :: $ selection_mode ($ crate :: prisma :: vocabulary_reading :: ManyArgs :: new ($ crate :: prisma :: vocabulary_reading :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: vocabulary_reading :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; readings $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: vocabulary_subject :: IncludeParam > :: into ($ crate :: prisma :: vocabulary_subject :: readings :: Include :: Fetch ($ crate :: prisma :: vocabulary_reading :: ManyArgs :: new ($ crate :: prisma :: vocabulary_reading :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: vocabulary_subject :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; auxiliary_meanings) => { "auxiliary_meanings" } ; (@ field_serde_name ; characters) => { "characters" } ; (@ field_serde_name ; component_subjects) => { "component_subjects" } ; (@ field_serde_name ; context_sentences) => { "context_sentences" } ; (@ field_serde_name ; lesson_position) => { "lesson_position" } ; (@ field_serde_name ; level) => { "level" } ; (@ field_serde_name ; meaning_mnemonic) => { "meaning_mnemonic" } ; (@ field_serde_name ; meanings) => { "meanings" } ; (@ field_serde_name ; reading_mnemonic) => { "reading_mnemonic" } ; (@ field_serde_name ; readings) => { "readings" } ; }
    pub use _include_vocabulary_subject as include;
    pub enum IncludeParam {
        Id(id::Include),
        AuxiliaryMeanings(auxiliary_meanings::Include),
        Characters(characters::Include),
        ComponentSubjects(component_subjects::Include),
        ContextSentences(context_sentences::Include),
        LessonPosition(lesson_position::Include),
        Level(level::Include),
        MeaningMnemonic(meaning_mnemonic::Include),
        Meanings(meanings::Include),
        ReadingMnemonic(reading_mnemonic::Include),
        Readings(readings::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AuxiliaryMeanings(data) => data.to_selection(),
                Self::Characters(data) => data.to_selection(),
                Self::ComponentSubjects(data) => data.to_selection(),
                Self::ContextSentences(data) => data.to_selection(),
                Self::LessonPosition(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::MeaningMnemonic(data) => data.to_selection(),
                Self::Meanings(data) => data.to_selection(),
                Self::ReadingMnemonic(data) => data.to_selection(),
                Self::Readings(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "auxiliary_meanings")]
        pub auxiliary_meanings: Option<Vec<super::auxiliary_meaning::Data>>,
        #[serde(rename = "characters")]
        pub characters: String,
        #[serde(rename = "component_subjects")]
        pub component_subjects: Option<Vec<super::subject_index::Data>>,
        #[serde(rename = "context_sentences")]
        pub context_sentences: Option<Vec<super::context_sentence::Data>>,
        #[serde(rename = "lesson_position")]
        pub lesson_position: i32,
        #[serde(rename = "level")]
        pub level: i32,
        #[serde(rename = "meaning_mnemonic")]
        pub meaning_mnemonic: String,
        #[serde(rename = "meanings")]
        pub meanings: Option<Vec<super::subject_meaning::Data>>,
        #[serde(rename = "reading_mnemonic")]
        pub reading_mnemonic: String,
        #[serde(rename = "readings")]
        pub readings: Option<Vec<super::vocabulary_reading::Data>>,
    }
    impl Data {
        pub fn auxiliary_meanings(
            &self,
        ) -> Result<
            &Vec<super::auxiliary_meaning::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.auxiliary_meanings.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(auxiliary_meanings)),
            )
        }
        pub fn component_subjects(
            &self,
        ) -> Result<&Vec<super::subject_index::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.component_subjects.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(component_subjects)),
            )
        }
        pub fn context_sentences(
            &self,
        ) -> Result<
            &Vec<super::context_sentence::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.context_sentences.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(context_sentences)),
            )
        }
        pub fn meanings(
            &self,
        ) -> Result<&Vec<super::subject_meaning::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.meanings
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(meanings),
                ))
        }
        pub fn readings(
            &self,
        ) -> Result<
            &Vec<super::vocabulary_reading::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.readings
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(readings),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        AuxiliaryMeanings(super::auxiliary_meaning::ManyArgs),
        ComponentSubjects(super::subject_index::ManyArgs),
        ContextSentences(super::context_sentence::ManyArgs),
        Meanings(super::subject_meaning::ManyArgs),
        Readings(super::vocabulary_reading::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::AuxiliaryMeanings(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::auxiliary_meaning::_outputs());
                    let mut builder =
                        ::prisma_client_rust::Selection::builder("auxiliary_meanings");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::ComponentSubjects(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_index::_outputs());
                    let mut builder =
                        ::prisma_client_rust::Selection::builder("component_subjects");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::ContextSentences(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::context_sentence::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("context_sentences");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Meanings(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::subject_meaning::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("meanings");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Readings(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::vocabulary_reading::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("readings");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        ConnectAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        DisconnectAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        SetAuxiliaryMeanings(Vec<super::auxiliary_meaning::UniqueWhereParam>),
        SetCharacters(String),
        ConnectComponentSubjects(Vec<super::subject_index::UniqueWhereParam>),
        DisconnectComponentSubjects(Vec<super::subject_index::UniqueWhereParam>),
        SetComponentSubjects(Vec<super::subject_index::UniqueWhereParam>),
        ConnectContextSentences(Vec<super::context_sentence::UniqueWhereParam>),
        DisconnectContextSentences(Vec<super::context_sentence::UniqueWhereParam>),
        SetContextSentences(Vec<super::context_sentence::UniqueWhereParam>),
        SetLessonPosition(i32),
        IncrementLessonPosition(i32),
        DecrementLessonPosition(i32),
        MultiplyLessonPosition(i32),
        DivideLessonPosition(i32),
        SetLevel(i32),
        IncrementLevel(i32),
        DecrementLevel(i32),
        MultiplyLevel(i32),
        DivideLevel(i32),
        SetMeaningMnemonic(String),
        ConnectMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
        DisconnectMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
        SetMeanings(Vec<super::subject_meaning::UniqueWhereParam>),
        SetReadingMnemonic(String),
        ConnectReadings(Vec<super::vocabulary_reading::UniqueWhereParam>),
        DisconnectReadings(Vec<super::vocabulary_reading::UniqueWhereParam>),
        SetReadings(Vec<super::vocabulary_reading::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAuxiliaryMeanings(where_params) => (
                    "auxiliary_meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::auxiliary_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetCharacters(value) => (
                    "characters".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectComponentSubjects(where_params) => (
                    "component_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComponentSubjects(where_params) => (
                    "component_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComponentSubjects(where_params) => (
                    "component_subjects".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_index::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectContextSentences(where_params) => (
                    "context_sentences".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::context_sentence::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectContextSentences(where_params) => (
                    "context_sentences".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::context_sentence::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetContextSentences(where_params) => (
                    "context_sentences".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::context_sentence::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideLessonPosition(value) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideLevel(value) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMeaningMnemonic(value) => (
                    "meaning_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMeanings(where_params) => (
                    "meanings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::subject_meaning::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReadingMnemonic(value) => (
                    "reading_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectReadings(where_params) => (
                    "readings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::vocabulary_reading::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectReadings(where_params) => (
                    "readings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::vocabulary_reading::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReadings(where_params) => (
                    "readings".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::vocabulary_reading::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Characters(::prisma_client_rust::Direction),
        LessonPosition(::prisma_client_rust::Direction),
        Level(::prisma_client_rust::Direction),
        MeaningMnemonic(::prisma_client_rust::Direction),
        ReadingMnemonic(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Characters(direction) => (
                    "characters".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LessonPosition(direction) => (
                    "lesson_position".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Level(direction) => (
                    "level".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MeaningMnemonic(direction) => (
                    "meaning_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReadingMnemonic(direction) => (
                    "reading_mnemonic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        AuxiliaryMeaningsSome(Vec<super::auxiliary_meaning::WhereParam>),
        AuxiliaryMeaningsEvery(Vec<super::auxiliary_meaning::WhereParam>),
        AuxiliaryMeaningsNone(Vec<super::auxiliary_meaning::WhereParam>),
        CharactersEquals(String),
        CharactersInVec(Vec<String>),
        CharactersNotInVec(Vec<String>),
        CharactersLt(String),
        CharactersLte(String),
        CharactersGt(String),
        CharactersGte(String),
        CharactersContains(String),
        CharactersStartsWith(String),
        CharactersEndsWith(String),
        CharactersMode(QueryMode),
        CharactersNot(String),
        ComponentSubjectsSome(Vec<super::subject_index::WhereParam>),
        ComponentSubjectsEvery(Vec<super::subject_index::WhereParam>),
        ComponentSubjectsNone(Vec<super::subject_index::WhereParam>),
        ContextSentencesSome(Vec<super::context_sentence::WhereParam>),
        ContextSentencesEvery(Vec<super::context_sentence::WhereParam>),
        ContextSentencesNone(Vec<super::context_sentence::WhereParam>),
        LessonPositionEquals(i32),
        LessonPositionInVec(Vec<i32>),
        LessonPositionNotInVec(Vec<i32>),
        LessonPositionLt(i32),
        LessonPositionLte(i32),
        LessonPositionGt(i32),
        LessonPositionGte(i32),
        LessonPositionNot(i32),
        LevelEquals(i32),
        LevelInVec(Vec<i32>),
        LevelNotInVec(Vec<i32>),
        LevelLt(i32),
        LevelLte(i32),
        LevelGt(i32),
        LevelGte(i32),
        LevelNot(i32),
        MeaningMnemonicEquals(String),
        MeaningMnemonicInVec(Vec<String>),
        MeaningMnemonicNotInVec(Vec<String>),
        MeaningMnemonicLt(String),
        MeaningMnemonicLte(String),
        MeaningMnemonicGt(String),
        MeaningMnemonicGte(String),
        MeaningMnemonicContains(String),
        MeaningMnemonicStartsWith(String),
        MeaningMnemonicEndsWith(String),
        MeaningMnemonicMode(QueryMode),
        MeaningMnemonicNot(String),
        MeaningsSome(Vec<super::subject_meaning::WhereParam>),
        MeaningsEvery(Vec<super::subject_meaning::WhereParam>),
        MeaningsNone(Vec<super::subject_meaning::WhereParam>),
        ReadingMnemonicEquals(String),
        ReadingMnemonicInVec(Vec<String>),
        ReadingMnemonicNotInVec(Vec<String>),
        ReadingMnemonicLt(String),
        ReadingMnemonicLte(String),
        ReadingMnemonicGt(String),
        ReadingMnemonicGte(String),
        ReadingMnemonicContains(String),
        ReadingMnemonicStartsWith(String),
        ReadingMnemonicEndsWith(String),
        ReadingMnemonicMode(QueryMode),
        ReadingMnemonicNot(String),
        ReadingsSome(Vec<super::vocabulary_reading::WhereParam>),
        ReadingsEvery(Vec<super::vocabulary_reading::WhereParam>),
        ReadingsNone(Vec<super::vocabulary_reading::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::AuxiliaryMeaningsSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AuxiliaryMeaningsEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::AuxiliaryMeaningsNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "auxiliary_meanings",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::CharactersEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CharactersNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CharactersLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CharactersMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::CharactersNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "characters",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ComponentSubjectsSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "component_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::ComponentSubjectsEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "component_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::ComponentSubjectsNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "component_subjects",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::ContextSentencesSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "context_sentences",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::ContextSentencesEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "context_sentences",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::ContextSentencesNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "context_sentences",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::LessonPositionEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LessonPositionNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LessonPositionLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LessonPositionNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "lesson_position",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LevelNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LevelLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::LevelNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "level",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::MeaningMnemonicEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningMnemonicNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningMnemonicLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicStartsWith(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "meaning_mnemonic",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )]),
                    )
                }
                Self::MeaningMnemonicEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningMnemonicMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::MeaningMnemonicNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "meaning_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::MeaningsSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningsEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MeaningsNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "meanings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingMnemonicEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingMnemonicNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingMnemonicLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicStartsWith(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "reading_mnemonic",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )]),
                    )
                }
                Self::ReadingMnemonicEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingMnemonicMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ReadingMnemonicNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "reading_mnemonic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ReadingsSome(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "readings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingsEvery(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "readings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReadingsNone(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "readings",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: i32,
            characters: String,
            lesson_position: i32,
            level: i32,
            meaning_mnemonic: String,
            reading_mnemonic: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(characters::set(characters));
            _params.push(lesson_position::set(lesson_position));
            _params.push(level::set(level));
            _params.push(meaning_mnemonic::set(meaning_mnemonic));
            _params.push(reading_mnemonic::set(reading_mnemonic));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(i32, String, i32, i32, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        id,
                        characters,
                        lesson_position,
                        level,
                        meaning_mnemonic,
                        reading_mnemonic,
                        mut _params,
                    )| {
                        _params.push(id::set(id));
                        _params.push(characters::set(characters));
                        _params.push(lesson_position::set(lesson_position));
                        _params.push(level::set(level));
                        _params.push(meaning_mnemonic::set(meaning_mnemonic));
                        _params.push(reading_mnemonic::set(reading_mnemonic));
                        _params
                    },
                )
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                id,
                characters,
                lesson_position,
                level,
                meaning_mnemonic,
                reading_mnemonic,
                mut _params,
            ): (i32, String, i32, i32, String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(characters::set(characters));
            _params.push(lesson_position::set(lesson_position));
            _params.push(level::set(level));
            _params.push(meaning_mnemonic::set(meaning_mnemonic));
            _params.push(reading_mnemonic::set(reading_mnemonic));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("VocabularySubject", _outputs()),
                vec![],
            )
        }
    }
}
pub mod _prisma {
    pub struct PrismaClient {
        executor: ::prisma_client_rust::Executor,
        query_schema: ::std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
    }
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub(super) fn _new_query_context(&self) -> ::prisma_client_rust::queries::QueryContext {
            ::prisma_client_rust::queries::QueryContext::new(&self.executor, &self.query_schema)
        }
        pub(super) fn _new(
            executor: ::prisma_client_rust::Executor,
            query_schema: std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
        ) -> Self {
            Self {
                executor,
                query_schema,
            }
        }
        pub fn _query_raw<T: serde::de::DeserializeOwned>(
            &self,
            query: ::prisma_client_rust::raw::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(
                ::prisma_client_rust::queries::QueryContext::new(
                    &self.executor,
                    &self.query_schema,
                ),
                query,
                super::DATABASE_STR,
            )
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::raw::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(
                ::prisma_client_rust::queries::QueryContext::new(
                    &self.executor,
                    &self.query_schema,
                ),
                query,
                super::DATABASE_STR,
            )
        }
        pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::queries::Result<T::ReturnType> {
            ::prisma_client_rust::batch(queries, &self.executor, &self.query_schema).await
        }
        pub fn user(&self) -> super::user::Actions {
            super::user::Actions { client: &self }
        }
        pub fn login_token(&self) -> super::login_token::Actions {
            super::login_token::Actions { client: &self }
        }
        pub fn subject_progress(&self) -> super::subject_progress::Actions {
            super::subject_progress::Actions { client: &self }
        }
        pub fn progress(&self) -> super::progress::Actions {
            super::progress::Actions { client: &self }
        }
        pub fn subject_meaning(&self) -> super::subject_meaning::Actions {
            super::subject_meaning::Actions { client: &self }
        }
        pub fn auxiliary_meaning(&self) -> super::auxiliary_meaning::Actions {
            super::auxiliary_meaning::Actions { client: &self }
        }
        pub fn kanji_reading(&self) -> super::kanji_reading::Actions {
            super::kanji_reading::Actions { client: &self }
        }
        pub fn vocabulary_reading(&self) -> super::vocabulary_reading::Actions {
            super::vocabulary_reading::Actions { client: &self }
        }
        pub fn subject_index(&self) -> super::subject_index::Actions {
            super::subject_index::Actions { client: &self }
        }
        pub fn radical_subject(&self) -> super::radical_subject::Actions {
            super::radical_subject::Actions { client: &self }
        }
        pub fn kanji_subject(&self) -> super::kanji_subject::Actions {
            super::kanji_subject::Actions { client: &self }
        }
        pub fn context_sentence(&self) -> super::context_sentence::Actions {
            super::context_sentence::Actions { client: &self }
        }
        pub fn vocabulary_subject(&self) -> super::vocabulary_subject::Actions {
            super::vocabulary_subject::Actions { client: &self }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum AuxiliaryMeaningScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "meaning")]
        Meaning,
        #[serde(rename = "auxiliary_type")]
        AuxiliaryType,
        #[serde(rename = "radicalSubjectId")]
        RadicalSubjectId,
        #[serde(rename = "kanjiSubjectId")]
        KanjiSubjectId,
        #[serde(rename = "vocabularySubjectId")]
        VocabularySubjectId,
    }
    impl ToString for AuxiliaryMeaningScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Meaning => "meaning".to_string(),
                Self::AuxiliaryType => "auxiliary_type".to_string(),
                Self::RadicalSubjectId => "radicalSubjectId".to_string(),
                Self::KanjiSubjectId => "kanjiSubjectId".to_string(),
                Self::VocabularySubjectId => "vocabularySubjectId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ContextSentenceScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "en")]
        En,
        #[serde(rename = "ja")]
        Ja,
        #[serde(rename = "vocabularySubjectId")]
        VocabularySubjectId,
    }
    impl ToString for ContextSentenceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::En => "en".to_string(),
                Self::Ja => "ja".to_string(),
                Self::VocabularySubjectId => "vocabularySubjectId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum KanjiReadingScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "reading")]
        Reading,
        #[serde(rename = "reading_type")]
        ReadingType,
        #[serde(rename = "primary")]
        Primary,
        #[serde(rename = "kanjiSubjectId")]
        KanjiSubjectId,
    }
    impl ToString for KanjiReadingScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Reading => "reading".to_string(),
                Self::ReadingType => "reading_type".to_string(),
                Self::Primary => "primary".to_string(),
                Self::KanjiSubjectId => "kanjiSubjectId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum KanjiSubjectScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "characters")]
        Characters,
        #[serde(rename = "lesson_position")]
        LessonPosition,
        #[serde(rename = "level")]
        Level,
        #[serde(rename = "meaning_hint")]
        MeaningHint,
        #[serde(rename = "meaning_mnemonic")]
        MeaningMnemonic,
        #[serde(rename = "reading_hint")]
        ReadingHint,
        #[serde(rename = "reading_mnemonic")]
        ReadingMnemonic,
    }
    impl ToString for KanjiSubjectScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Characters => "characters".to_string(),
                Self::LessonPosition => "lesson_position".to_string(),
                Self::Level => "level".to_string(),
                Self::MeaningHint => "meaning_hint".to_string(),
                Self::MeaningMnemonic => "meaning_mnemonic".to_string(),
                Self::ReadingHint => "reading_hint".to_string(),
                Self::ReadingMnemonic => "reading_mnemonic".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LoginTokenScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "time")]
        Time,
        #[serde(rename = "value")]
        Value,
    }
    impl ToString for LoginTokenScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::Time => "time".to_string(),
                Self::Value => "value".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProgressScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "current_level")]
        CurrentLevel,
    }
    impl ToString for ProgressScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CurrentLevel => "current_level".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum RadicalSubjectScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "characters")]
        Characters,
        #[serde(rename = "lesson_position")]
        LessonPosition,
        #[serde(rename = "level")]
        Level,
        #[serde(rename = "meaning_mnemonic")]
        MeaningMnemonic,
    }
    impl ToString for RadicalSubjectScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Characters => "characters".to_string(),
                Self::LessonPosition => "lesson_position".to_string(),
                Self::Level => "level".to_string(),
                Self::MeaningMnemonic => "meaning_mnemonic".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SubjectIndexScalarFieldEnum {
        #[serde(rename = "subject_type")]
        SubjectType,
        #[serde(rename = "subjectId")]
        SubjectId,
    }
    impl ToString for SubjectIndexScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::SubjectType => "subject_type".to_string(),
                Self::SubjectId => "subjectId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SubjectMeaningScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "accepted_answer")]
        AcceptedAnswer,
        #[serde(rename = "meaning")]
        Meaning,
        #[serde(rename = "primary")]
        Primary,
        #[serde(rename = "radicalSubjectId")]
        RadicalSubjectId,
        #[serde(rename = "kanjiSubjectId")]
        KanjiSubjectId,
        #[serde(rename = "vocabularySubjectId")]
        VocabularySubjectId,
    }
    impl ToString for SubjectMeaningScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::AcceptedAnswer => "accepted_answer".to_string(),
                Self::Meaning => "meaning".to_string(),
                Self::Primary => "primary".to_string(),
                Self::RadicalSubjectId => "radicalSubjectId".to_string(),
                Self::KanjiSubjectId => "kanjiSubjectId".to_string(),
                Self::VocabularySubjectId => "vocabularySubjectId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SubjectProgressScalarFieldEnum {
        #[serde(rename = "subject_id")]
        SubjectId,
        #[serde(rename = "level")]
        Level,
        #[serde(rename = "skill_level")]
        SkillLevel,
        #[serde(rename = "next_review")]
        NextReview,
        #[serde(rename = "progress_id")]
        ProgressId,
    }
    impl ToString for SubjectProgressScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::SubjectId => "subject_id".to_string(),
                Self::Level => "level".to_string(),
                Self::SkillLevel => "skill_level".to_string(),
                Self::NextReview => "next_review".to_string(),
                Self::ProgressId => "progress_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "password_hash")]
        PasswordHash,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "progress_id")]
        ProgressId,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Email => "email".to_string(),
                Self::PasswordHash => "password_hash".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::ProgressId => "progress_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VocabularyReadingScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "reading")]
        Reading,
        #[serde(rename = "primary")]
        Primary,
        #[serde(rename = "accepted_answer")]
        AcceptedAnswer,
        #[serde(rename = "vocabularySubjectId")]
        VocabularySubjectId,
    }
    impl ToString for VocabularyReadingScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Reading => "reading".to_string(),
                Self::Primary => "primary".to_string(),
                Self::AcceptedAnswer => "accepted_answer".to_string(),
                Self::VocabularySubjectId => "vocabularySubjectId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VocabularySubjectScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "characters")]
        Characters,
        #[serde(rename = "lesson_position")]
        LessonPosition,
        #[serde(rename = "level")]
        Level,
        #[serde(rename = "meaning_mnemonic")]
        MeaningMnemonic,
        #[serde(rename = "reading_mnemonic")]
        ReadingMnemonic,
    }
    impl ToString for VocabularySubjectScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Characters => "characters".to_string(),
                Self::LessonPosition => "lesson_position".to_string(),
                Self::Level => "level".to_string(),
                Self::MeaningMnemonic => "meaning_mnemonic".to_string(),
                Self::ReadingMnemonic => "reading_mnemonic".to_string(),
            }
        }
    }
}
pub use _prisma::PrismaClient;
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
pub enum ReadingType {
    #[serde(rename = "ONYOMI")]
    Onyomi,
    #[serde(rename = "KUNYOMI")]
    Kunyomi,
    #[serde(rename = "NANORI")]
    Nanori,
}
impl ToString for ReadingType {
    fn to_string(&self) -> String {
        match self {
            Self::Onyomi => "ONYOMI".to_string(),
            Self::Kunyomi => "KUNYOMI".to_string(),
            Self::Nanori => "NANORI".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
pub enum SubjectType {
    #[serde(rename = "KANJI")]
    Kanji,
    #[serde(rename = "VOCABULARY")]
    Vocabulary,
    #[serde(rename = "RADICAL")]
    Radical,
}
impl ToString for SubjectType {
    fn to_string(&self) -> String {
        match self {
            Self::Kanji => "KANJI".to_string(),
            Self::Vocabulary => "VOCABULARY".to_string(),
            Self::Radical => "RADICAL".to_string(),
        }
    }
}
